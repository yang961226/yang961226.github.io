<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>生命周期与Lifecycle | 安卓现代化开发指南</title>
    <meta name="generator" content="VuePress 1.9.10">
    <link rel="icon" href="/modern_android_logo.png">
    <meta name="description" content="这里提供安卓现代化开发参考文档，适合新手和进阶开发。">
    
    <link rel="preload" href="/assets/css/0.styles.5b9cc425.css" as="style"><link rel="preload" href="/assets/js/app.a2aee210.js" as="script"><link rel="preload" href="/assets/js/7.83b45c61.js" as="script"><link rel="preload" href="/assets/js/2.4e1717d6.js" as="script"><link rel="preload" href="/assets/js/1.448f1724.js" as="script"><link rel="preload" href="/assets/js/14.a39c521a.js" as="script"><link rel="prefetch" href="/assets/js/10.06a373d0.js"><link rel="prefetch" href="/assets/js/11.266dbd4f.js"><link rel="prefetch" href="/assets/js/15.b5939b09.js"><link rel="prefetch" href="/assets/js/16.3a23acb4.js"><link rel="prefetch" href="/assets/js/17.490c51cf.js"><link rel="prefetch" href="/assets/js/18.eda269f5.js"><link rel="prefetch" href="/assets/js/19.61278165.js"><link rel="prefetch" href="/assets/js/20.3eff384d.js"><link rel="prefetch" href="/assets/js/21.e88efa15.js"><link rel="prefetch" href="/assets/js/22.4e8fd7d4.js"><link rel="prefetch" href="/assets/js/23.fcde4691.js"><link rel="prefetch" href="/assets/js/24.b7ea5092.js"><link rel="prefetch" href="/assets/js/25.783749da.js"><link rel="prefetch" href="/assets/js/26.7022c712.js"><link rel="prefetch" href="/assets/js/27.b201cbd1.js"><link rel="prefetch" href="/assets/js/28.b996e086.js"><link rel="prefetch" href="/assets/js/29.fd0bdf51.js"><link rel="prefetch" href="/assets/js/3.e0c20fb4.js"><link rel="prefetch" href="/assets/js/30.7e183c05.js"><link rel="prefetch" href="/assets/js/31.364e9117.js"><link rel="prefetch" href="/assets/js/32.0ce788fa.js"><link rel="prefetch" href="/assets/js/33.a0652f64.js"><link rel="prefetch" href="/assets/js/34.2e8cbc55.js"><link rel="prefetch" href="/assets/js/35.77af379f.js"><link rel="prefetch" href="/assets/js/36.58d58b5d.js"><link rel="prefetch" href="/assets/js/37.8e790ffe.js"><link rel="prefetch" href="/assets/js/38.22572e4e.js"><link rel="prefetch" href="/assets/js/39.33d87db9.js"><link rel="prefetch" href="/assets/js/4.9374ab88.js"><link rel="prefetch" href="/assets/js/40.053e530f.js"><link rel="prefetch" href="/assets/js/41.4a7b5ec5.js"><link rel="prefetch" href="/assets/js/5.bfc822b3.js"><link rel="prefetch" href="/assets/js/6.c6a52294.js"><link rel="prefetch" href="/assets/js/8.d751b2d9.js"><link rel="prefetch" href="/assets/js/9.9f743a74.js"><link rel="prefetch" href="/assets/js/vendors~docsearch.b33fc384.js">
    <link rel="stylesheet" href="/assets/css/0.styles.5b9cc425.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container" data-v-7dd95ae2><div data-v-7dd95ae2><div class="password-shadow password-wrapper-out" style="display:none;" data-v-59e6cb88 data-v-7dd95ae2 data-v-7dd95ae2><h3 class="title" data-v-59e6cb88>安卓现代化开发指南</h3> <p class="description" data-v-59e6cb88>这里提供安卓现代化开发参考文档，适合新手和进阶开发。</p> <label id="box" class="inputBox" data-v-59e6cb88><input type="password" value="" data-v-59e6cb88> <span data-v-59e6cb88>Konck! Knock!</span> <button data-v-59e6cb88>OK</button></label> <div class="footer" data-v-59e6cb88><span data-v-59e6cb88><i class="iconfont reco-theme" data-v-59e6cb88></i> <a target="blank" href="https://vuepress-theme-reco.recoluan.com" data-v-59e6cb88>vuePress-theme-reco</a></span> <span data-v-59e6cb88><i class="iconfont reco-copyright" data-v-59e6cb88></i> <a data-v-59e6cb88><!---->
          
        <!---->
        2023
      </a></span></div></div> <div class="hide" data-v-7dd95ae2><header class="navbar" data-v-7dd95ae2><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">安卓现代化开发指南</span></a> <div class="links"><div class="color-picker"><a class="color-button"><i class="iconfont reco-color"></i></a> <div class="color-picker-menu" style="display:none;"><div class="mode-options"><h4 class="title">Choose mode</h4> <ul class="color-mode-options"><li class="dark">dark</li><li class="auto active">auto</li><li class="light">light</li></ul></div></div></div> <!----> <nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link"><i class="undefined"></i>
  首页
</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="undefined"></i>
      晴天小庭
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="https://juejin.cn/user/114798491603527" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="undefined"></i>
  掘金主页
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul></div></div> <!----></nav></div></header> <div class="sidebar-mask" data-v-7dd95ae2></div> <aside class="sidebar" data-v-7dd95ae2><div class="personal-info-wrapper" data-v-1fad0c41 data-v-7dd95ae2><!----> <!----> <div class="num" data-v-1fad0c41><div data-v-1fad0c41><h3 data-v-1fad0c41>4</h3> <h6 data-v-1fad0c41>Articles</h6></div> <div data-v-1fad0c41><h3 data-v-1fad0c41>0</h3> <h6 data-v-1fad0c41>Tags</h6></div></div> <ul class="social-links" data-v-1fad0c41></ul> <hr data-v-1fad0c41></div> <nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link"><i class="undefined"></i>
  首页
</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="undefined"></i>
      晴天小庭
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="https://juejin.cn/user/114798491603527" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="undefined"></i>
  掘金主页
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul></div></div> <!----></nav> <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><a href="/" class="sidebar-heading clickable router-link-active"><span>欢迎学习</span> <!----></a> <ul class="sidebar-links sidebar-group-items"><li><a href="/" aria-current="page" class="sidebar-link">简介</a></li></ul></section></li><li><section class="sidebar-group collapsable depth-0"><a href="/blogs/生命周期" class="sidebar-heading clickable open active"><span>学习目录</span> <span class="arrow down"></span></a> <ul class="sidebar-links sidebar-group-items"><li><a href="/blogs/生命周期.html" class="active sidebar-link">生命周期与Lifecycle</a></li><li><a href="/blogs/状态保存.html" class="sidebar-link">状态保存与SavedState</a></li><li><a href="/blogs/ViewModel.html" class="sidebar-link">传世不朽ViewModel</a></li></ul></section></li></ul> </aside> <div class="password-shadow password-wrapper-in" style="display:none;" data-v-59e6cb88 data-v-7dd95ae2><h3 class="title" data-v-59e6cb88>生命周期与Lifecycle</h3> <!----> <label id="box" class="inputBox" data-v-59e6cb88><input type="password" value="" data-v-59e6cb88> <span data-v-59e6cb88>Konck! Knock!</span> <button data-v-59e6cb88>OK</button></label> <div class="footer" data-v-59e6cb88><span data-v-59e6cb88><i class="iconfont reco-theme" data-v-59e6cb88></i> <a target="blank" href="https://vuepress-theme-reco.recoluan.com" data-v-59e6cb88>vuePress-theme-reco</a></span> <span data-v-59e6cb88><i class="iconfont reco-copyright" data-v-59e6cb88></i> <a data-v-59e6cb88><!---->
          
        <!---->
        2023
      </a></span></div></div> <div data-v-7dd95ae2><div data-v-7dd95ae2><main class="page"><section style="display:;"><div class="page-title"><h1 class="title">生命周期与Lifecycle</h1> <div data-v-8a445198><i class="iconfont reco-account" data-v-8a445198><span data-v-8a445198>晴天小庭</span></i> <i class="iconfont reco-date" data-v-8a445198><span data-v-8a445198>11/23/2023</span></i> <!----> <!----></div></div> <div class="theme-reco-content content__default"><h1 id="生命周期的前世今生"><a href="#生命周期的前世今生" class="header-anchor">#</a> 生命周期的前世今生</h1> <h2 id="_1-1、前世-初识篇"><a href="#_1-1、前世-初识篇" class="header-anchor">#</a> 1.1、前世——初识篇</h2> <p>天地初开，一切皆为混沌的时代，安卓宇宙中诞生了名为<code>Activity</code>（活动）的组件，<code>Activity</code>
是Android应用中最关键的组件，一个<code>Activity</code>
通常对应的是App的一个页面，当手机使用者在不同的页面之间导航的时候，新的<code>Activity</code>
会诞生，同时也会在特定的时候销毁。一个页面的诞生之初到它销毁的这段时间，名为「生命周期」。</p> <p>理解并掌握生命周期是每一个Android修炼者的必修功力，因为生命周期的每一个阶段均代表<code>Activity</code>
处于不同的状态之中，一旦错误处理生命周期周期，修炼者轻则内伤残疾（手机耗电过多，丢失信息），重则走火入魔（程序崩溃）。</p> <p>关于生命周期，江湖中一直流传着一张「Activity生命周期总览图」，但个中奥秘，却鲜为人知，因此少有人能够修炼到最高境界：</p> <center><img src="https://developer.android.google.cn/guide/components/images/activity_lifecycle.png?hl=zh-cn" alt="Activity生命周期" style="zoom:67%;"></center> <p>由图可见，<code>Activity</code>的生命周期中，提供了6种回调：<code>onCreate()</code>、<code>onStart()</code>、<code>onResume()</code>、<code>onPause()</code>、<code>onStop()</code>、<code>onDestroy()</code>。</p> <blockquote><p><strong>需要特别注意的是：<strong>这</strong>仅仅</strong>是一种回调，与我们通常的认识不同都是，生命周期的某个阶段是指一个<strong>时间段</strong>，而回调或者说事件只是一个瞬间，换句话来说，onCreate并不是指生命周期中存在一个阶段名为onCreate，而是<code>Activity</code>触发了onCreate事件，即将进入已创建阶段。</p></blockquote> <p>然而可惜的是，在远古Android的设计中，Android的创世神并没有为开发者提供具体的生命周期阶段的概念，仅仅是提供了进入某个生命周期阶段的回调，因此上述提到的“<strong>已创建</strong>”这个状态在原生安卓的概念中并不存在。然而在后人的努力中，生命周期阶段这一概念最终得到确定与落实，不过这都是后话了。</p> <h2 id="_1-2、前世-详解篇"><a href="#_1-2、前世-详解篇" class="header-anchor">#</a> 1.2、前世——详解篇</h2> <h3 id="_1-2-1、oncreate-、ondestroy"><a href="#_1-2-1、oncreate-、ondestroy" class="header-anchor">#</a> 1.2.1、onCreate()、onDestroy()</h3> <ul><li><p><strong>onCreate()</strong>：<code>Activity</code>生命周期的起点，首次被系统创建时触发，整个生命周期只会触发一次。此回调通常用于执行页面View的设置，例如<code>setContentView()</code>。</p></li> <li><p><strong>onDestroy()</strong>：<code>Activity</code>生命周期的终点，在<code>Activity</code>被销毁前触发，此回调的有两种情况被调用：</p></li></ul> <ol><li>用户手动关闭<code>Activity</code>（按返回键）或者系统主动关闭<code>Activity</code>（一般是App进程因内存不足被销毁，导致<code>Activity</code>也被销毁）。</li> <li>配置变更（设备旋转、语言切换等）。</li></ol> <p>简单来说，onCreate()是<code>Activity</code>被创建的时刻，onDestroy()是<code>Activity</code>即将被销毁的时刻。</p> <p>一个<code>Activity</code>进入onDestroy()之后，理应被GC回收，但是如果此时它仍然被引用（例如被某些网络请求的回调中被引用），那么此<code>Activity</code>就会导致<strong>内存泄漏</strong>，这也是所有Android开发者需要关注其生命周期的原因。</p> <h3 id="_1-2-2、onstart-、onstop"><a href="#_1-2-2、onstart-、onstop" class="header-anchor">#</a> 1.2.2、onStart()、onStop()</h3> <ul><li><strong>onStart()</strong>：当<code>Activity</code>在onCreate()之后不久就会触发此回调，说明了<code>Activity</code>此刻进入了“已开始”的状态，但是此刻的<code>Activity</code>仍然<strong>未获取焦点</strong>。</li></ul> <blockquote><p>很多Android开发者一直搞不懂Activity为什么会存在一个<strong>可见但是没有获取焦点</strong>的状态，会存在这种疑惑的原因是因为Android通常作为<strong>一种移动设备的系统而存在</strong>，而移动设备由于其特殊性，通常也只会同屏存在一个页面，因此<strong>可见但是没有获取焦点</strong>这种状态几乎只存在一瞬间（它马上就会遮住之前正在交互的页面），然而我们以电脑系统的角度来看，电脑系统的桌面上基本都是多窗口并存的，然而即使存在了多窗口，用户能交互的也仅仅只有获取焦点的那个窗口。</p></blockquote> <p>因此，<strong>可见但是没有获取焦点</strong>的窗口，就像是电脑上那些打开着、但被用户正在交互的窗口挡住的那些窗口，假如电脑桌面上存在着一个QQ窗口，然而用户正在编写一个Word文档，那么被Word挡住的那个QQ窗口，就是<strong>可见但未获取焦点</strong>的窗口，下面用一张图区别一下onStart()和onResume()的区别：</p> <center><img src="/assets/img/lifecycle_36.76fb3868.png" alt="生命周期图36" style="zoom:76%;"></center> <ul><li><strong>onStop()</strong>：当一个<code>Activity</code>从<strong>可见但是没有获取到焦点</strong>的状态变为<strong>完全不可见</strong>的状态时就会触发此回调，按照上文类比，这种情况通常可以理解为：<strong>电脑桌面上的一个被遮挡的窗口被最小化了</strong>。</li></ul> <h3 id="_1-2-3、onresume-、onpause"><a href="#_1-2-3、onresume-、onpause" class="header-anchor">#</a> 1.2.3、onResume()、onPause()</h3> <ul><li><p><strong>onResume()</strong>：当<code>Activity</code>从<strong>可见但是没有获取焦点</strong>的状态变成<strong>可见同时获取焦点</strong>的状态时，触发此回调，同样按照电脑系统的角度来理解，这种情况通常可以理解为：<strong>电脑桌面上的一个被遮挡的窗口此刻被用户交互了</strong>。</p></li> <li><p><strong>onPause()</strong>：当<code>Activity</code>从“<strong>可见同时获取焦点</strong>”的状态变成<strong>可见但是没有获取焦点</strong>的状态时，触发此回调，同样同样按照电脑系统的角度来理解，这种情况通常可以理解为：<strong>电脑桌面上的一个正在被用户交互的窗口，由于用户操作了其他窗口，导致当前的窗口被遮挡了，也因此失去了焦点</strong>。</p></li></ul> <h2 id="_1-3、前世-总结篇"><a href="#_1-3、前世-总结篇" class="header-anchor">#</a> 1.3、前世——总结篇</h2> <p>我们从电脑系统的窗口去理解<code>Activity</code>的生命周期：</p> <ol><li>启动一个程序的时候，程序就会在电脑桌面上创建一个窗口，创建的那一瞬间（通常会很快，可能不需要1秒）就相当于<code>Activity</code>的<code>onCreate()</code>。</li> <li>创建完成后，窗口就可以被用户所看见了，被用户看到的那一瞬间就相当于<code>Activity</code>的<code>onStart()</code>。</li> <li>通常来说，一个新启动的程序会自动获得焦点并可被用户交互，因此onStart()之后，窗口会被置顶到顶层，这一瞬间就相当于<code>Activity</code>的<code>onResume()</code>。</li> <li>当用户选择其他窗口时，之前交互的窗口并不会消失，而是会失去焦点并被用户最新交互的窗口所遮挡，这一瞬间就相当于<code>Activity</code>的<code>onPause()</code>。</li> <li>当用户最小化窗口时，窗口就会进入后台（并不是销毁）而且并不能被用户所看见，这一瞬间就相当于进入了<code>Activity</code>的<code>onStop()</code>。</li> <li>当用户关闭程序亦或者电脑内存不足时，程序被销毁，窗口同时也被销毁了，这一瞬间就相当于进入了<code>Activity</code>的<code>onDestroy()</code>。</li></ol> <p>一个窗口当然可以失去焦点后重新获取焦点，因此<code>onPause()</code>和<code>onResume()</code>可能在生命周期中多次被执行，同理窗口也可以最小化之后重新最大化，<code>onStart()</code>和<code>onStop()</code>也可能在生命周期中多次被执行。只不过对于移动设备来说，几乎不存在页面失去焦点后又重新获得焦点的情况，因为移动设备的页面绝大多数情况都是一个页面可被用户交互，被挡住的页面完全不可见，即等价于电脑系统中只存在一个最大化的页面，所以移动设备的<code>Activity</code>的生命周期通常只会在<code>onStart()</code>和<code>onStop()</code>两者之间流转（当然，仍然会遵循onStart()-&gt;onResumt()-&gt;onPause()-&gt;onStop()的顺序）。</p> <p>而一个窗口只能被创建和销毁一次，因此在<code>Activity</code>的生命周期中，onCreate()和onDestroy()只会被调用一次。</p> <blockquote><p>上文中提到，原生的Android生命周期设计中，只提供了进入某个生命周期状态的回调，并没有提供具体的状态的定义，例如onCreate()与onStart()之间的状态叫什么呢，官方的文档提到了这个叫“已创建”的状态，然而这只存在于文本性的文档中，这在代码中并不存在，只能作为一种“共识”的定义。这也为开发者之间沟通生命周期带来了极大的困扰。</p></blockquote> <h2 id="_2-1、今生-初识篇"><a href="#_2-1、今生-初识篇" class="header-anchor">#</a> 2.1、今生——初识篇</h2> <p><img src="https://blogger.googleusercontent.com/img/a/AVvXsEgo2-I1LhMjWd1zzpIQXzjMCPoZeUZc35n43UosKDuLMyP7rIDe8cGfs23tmkSAed6Wxw9EoNTIpvvWCljermK_lCu0etlrCnONx3WeXMCGe-s8I45hYhuVo6w_Q2UTNATMTA70t2o9MS5p2pBdPFz5Ye4b2ajOJjNlW9rELtqWcEW4O1Rkzy4lfqRO" alt="Jetpack"></p> <p>经历漫长的混沌时代之后，Jetpack携带着「Lifecycle」正式进入到了Android的世界中，「Lifecycle」为千千万万的Android修炼者带来了福音，因为它比起传统的基于回调的方式来感知生命周期的方式有以下的优点：</p> <ol><li><strong>提出了「生命周期状态」的概念，弥补了安卓传统的生命周期只有事件没有状态的缺陷</strong></li> <li><strong>将生命周期管理从页面（如Activity和Fragment）脱离，将生命周期监听的职责转移到组件中，降低页面与组件的耦合度。</strong></li></ol> <p>为了让读者更加清晰使用「Lifecycle」与不使用它之间的区别，这里使用两个代码案例来对比：</p> <ul><li>首先，定义一个常见的基于回调的监听类，每秒钟会对外广播一次字符串。</li></ul> <center><img src="/assets/img/lifecycle_01.786b4a33.png" alt="生命周期图1" style="zoom:76%;"></center> <ul><li><p>在<code>Activity</code>中的onCreate()阶段初始化监听，然后在onStart()中开启监听，在onStop()中关闭监听，这样的好处是当页面不可见的时候不会浪费手机性能。</p> <center><img src="/assets/img/lifecycle_02.0626e949.png" alt="生命周期图2" style="zoom:76%;"></center></li></ul> <p>以上便是传统安卓开发中最直接也是最常见的一种根据生命周期来实现监听的方式，让我们分析一下这种方式的缺点：</p> <ol><li><strong>真实业务开发中，同一页面中往往存在大量的生命周期监听需求，<code>Activity</code>等生命周期组件会同时管理大量的组件，让代码难以维护。</strong></li> <li><strong>代码缺乏一致性，需要监听生命周期的组件存在许多模板代码。试想一下，一个需要在onStart()启动，在onStop()关闭的、同时在项目中大量存在的组件，某天需要它在onResume()做一些操作，那将会导致灾难，因为需要每一处使用它的代码中增加onResume()的修改，一旦遗漏这个修改将会导致不可预知的bug。</strong></li> <li><strong>无法获取实时的生命周期状态。假设在onStart()的阶段，需要执行一个网络请求或者其他耗时操作之后再调用<code>listener.start()</code>的场景下，无法保证此刻页面仍然处于可见的状态，开发者也无法获取「当前所处状态」来避免不可见的时候仍然调用<code>listener.start()</code>（这个缺陷上文已经提到，原生安卓生命周期只提供了生命周期事件而没有生命周期状态）。</strong></li></ol> <p>让我们看一看使用了「Lifecycle」库之后的生命周期是如何实现监听的：</p> <center><img src="/assets/img/lifecycle_08.3ee91be3.png" alt="生命周期图8" style="zoom:76%;"></center> <p>我们让需要监听<code>Activity</code>生命周期的<code>MyListener</code>组件实现<code>DefaultLifecycleObserver</code>接口，然后重写onStart()、onStop()方法，然后直接在<code>Activity</code>中获取<code>lifecycle</code>然后调用其<code>addObserver()</code>即可。</p> <p>我们会发现，「生命周期管理」的责任从<code>Activity</code>转移到了组件中，<code>Activity</code>本身只负责对外广播自身的生命周期，这样极大减少了<code>Activity</code>的维护负担。</p> <h2 id="_2-2、今生-详解篇"><a href="#_2-2、今生-详解篇" class="header-anchor">#</a> 2.2、今生——详解篇</h2> <h3 id="_2-2-1、lifecycle"><a href="#_2-2-1、lifecycle" class="header-anchor">#</a> 2.2.1、<a href="https://developer.android.google.cn/reference/androidx/lifecycle/Lifecycle" target="_blank" rel="noopener noreferrer">Lifecycle<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></h3> <p><em>Lifecycle包含两个定义，一个指的是Jetpack库中的Lifecycle组件库，一个指的是Lifecycle组件库中的一个核心类，后文中如果没有特指情况下，文章中描述的默认为类</em></p> <p>上文中提到，安卓原生中只有描述生命周期的事件，缺乏一种描述当前生命周期所处的状态，但是「Lifecycle」库中补全了状态，下图中阐述了事件与状态的关系：</p> <p><img src="https://developer.android.google.cn/static/images/topic/libraries/architecture/lifecycle-states.svg?hl=zh-cn" alt="Activity生命周期的状态与事件"></p> <p>根据「Lifecycle」库的定义，一个生命周期状态的起点是「Initialized」，终点是「Destroyed」，当发生生命周期事件时，生命周期状态就会发生移动，包括<strong>状态提升</strong>和<strong>状态下降</strong>。</p> <blockquote><p>我们把状态从Initialized到Resumed当做一个从小到大的状态，如果状态值变小了，则称为<strong>状态下降</strong>，反之则为<strong>状态提升</strong>。</p></blockquote> <p>初步的定义有了，让我们把视角聚焦于<code>Lifecycle</code>类的源码：</p> <center><img src="/assets/img/lifecycle_03.92188481.png" alt="lifecycle_03" style="zoom:76%;"></center> <p>可以看到，<code>Lifecycle</code>类的设计基本遵循生命周期事件与状态图例，一个<code>Lifecycle</code>只有2个核心功能：</p> <ol><li><strong>缓存当前的生命周期状态（currentState）。</strong></li> <li><strong>添加与移除生命周期观察者。</strong></li></ol> <p>上述代码中，对<code>Event</code>和<code>State</code>的部分代码进行了省略，下面展开讲解：</p> <center><img src="/assets/img/lifecycle_04.01e147cf.png" alt="lifecycle_04" style="zoom:76%;"></center> <p>首先是<code>Event</code>类，<code>Event</code>类对应的是生命周期事件，也就是原生安卓生命周期的事件，即onCreate()、onPause()等。</p> <p>该类提供了一个<code>targetState</code>的属性，指的是发生了该事件之后，生命周期状态发生改变的状态目标。</p> <blockquote><p>例如发生了ON_CREATE事件，这是状态从「Initialized」向「Created」转移的瞬间，那么targetState自然就是「State.CREATED」了；同理发生ON_STOP事件时，是状态从「Started」向「Created」转移的瞬间，targetState也是「State.CREATED」。</p> <p>此处不必死记硬背，只需要配合<strong>状态与事件图</strong>理解其意义即可。</p></blockquote> <p>该类还提供了四个方法，downFrom()、downTo()、upFrom()、upTo()，这些都是当<strong>状态发生提升或者降级的时候，方便获取对应的事件</strong>的便捷方法，以downFrom()举例：</p> <blockquote><p>downFrom(state:State)的含义是获取会导致state发生状态下降的事件，假如State.Created，发生什么事件会导致状态从State.Created下降呢，我们回去查看<strong>状态与事件图</strong>，发现是发生了ON_DESTROY事件，那么该方法就会返回ON_DESTROY。</p> <p>此处不必死记硬背，只需要配合<strong>状态与事件图</strong>理解其意义即可。</p></blockquote> <p>看完了<strong>Event</strong>，我们把视角转向<strong>State</strong>：</p> <center><img src="/assets/img/lifecycle_05.859710aa.png" alt="lifecycle_05" style="zoom:50%;"></center> <p><code>State</code>的代码非常简单甚至不用一丝的省略，除了枚举值外仅有一个方法：<strong>isAtLeast(state:State)</strong>，此方法的含义是用于判断当前的状态是否大于或等于目标值的状态。</p> <p>如何理解呢？还记得上文提到的吗，状态是有大小的：</p> <blockquote><p>我们把状态从Initialized到Resumed当做一个从小到大的状态，如果状态值变小了，则称为<strong>状态下降</strong>，反之则为<strong>状态提升</strong>。</p></blockquote> <p>因此对于生命周期的状态而言，Created是比Initialized<strong>大</strong>的，<code>isAtLeast(state:State)</code>的含义就是判断生命周期是否比某个预期值“走的更远”了，如果一个行为可以在组件创建后被执行，那么换句话说，只要生命周期的状态大于或者等于Created即可。</p> <p>上文中提到，原生的生命周期回调无法实时获取生命周期所处的状态，一旦在生命周期回调方法中执行一些耗时操作，就无法耗时操作结束后，仍处于安全的生命周期区间，例如下面的代码：</p> <center><img src="/assets/img/lifecycle_06.7bc15dd4.png" alt="lifecycle_06" style="zoom:50%;"></center> <p>我们尝试在onStart()中执行一段耗时操作再开启监听，但是执行耗时操作期间无法<code>Activity</code>是否已经处于onStop()了，此刻我们就可以使用<code>isAtLeast(state:State)</code>来判断耗时操作结束后的生命周期状态：</p> <center><img src="/assets/img/lifecycle_07.2036a10d.png" alt="lifecycle_07" style="zoom:50%;"></center> <p>可见，「Lifecycle」库确实解决了生命周期只有事件没有状态的问题，开发者可以轻易获取当前的生命周期所处的阶段。</p> <h3 id="_2-2-2、lifecycleowner"><a href="#_2-2-2、lifecycleowner" class="header-anchor">#</a> 2.2.2、<a href="https://developer.android.google.cn/reference/androidx/lifecycle/LifecycleOwner" target="_blank" rel="noopener noreferrer">LifecycleOwner<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></h3> <p>首先，我们看看它的源码：</p> <center><img src="/assets/img/lifecycle_09.fa2b19e2.png" alt="lifecycle_09" style="zoom:50%;"></center> <p>非常的简单，只是给实现者对外提供一个获取<code>Lifecycle</code>的入口，为什么要这样设计呢？还记得<code>Lifecycle</code>吗，它并不是一个接口而是一个抽象类，在Jvm中是单继承的，因此不太可能会让带有生命周期的组件直接继承<code>Lifecycle</code>抽象类。</p> <p>因此在实际使用中，带有生命周期的组件和<code>Lifecycle</code>是包含的关系，即下图的情况：</p> <center><img src="/assets/img/lifecycle_10.d54d2e00.png" alt="lifecycle_10" style="zoom:50%;"></center> <blockquote><p>为什么谷歌的开发人员要如此奇怪呢，让<code>Lifecycle</code>变成接口，让Activity实现接口不一样能让组件访问到<code>Lifecycle</code>吗？</p> <p>先别急，<code>Lifecycle</code>的具体实现我们还没看，等到那一节将会解答这个疑问。</p></blockquote> <p>总结：<code>LifecycleOwner</code>只是一个简单的对外提供访问<code>Lifecycle</code>的接口。</p> <h3 id="_2-2-3、lifecycleobserver"><a href="#_2-2-3、lifecycleobserver" class="header-anchor">#</a> 2.2.3、<a href="https://developer.android.google.cn/reference/androidx/lifecycle/LifecycleObserver" target="_blank" rel="noopener noreferrer">LifecycleObserver<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></h3> <p>此处就不放代码了，因为这是一个空接口，作用是将其<strong>实现者变成一个生命周期的观察者</strong>。</p> <p>其本身不起作用，业务中我们通常使用其子接口，例如<code>DefaultLifecycleObserver</code>、<code>LifecycleEventObserver</code>等，可以回去查看2.1节的<code>MyListener</code>实现了<code>DefaultLifecycleObserver</code>之后是如何感知<code>Activity</code>的生命周期的。</p> <h3 id="_2-2-4、lifecycleregistry"><a href="#_2-2-4、lifecycleregistry" class="header-anchor">#</a> 2.2.4、<a href="https://developer.android.google.cn/reference/androidx/lifecycle/LifecycleRegistry" target="_blank" rel="noopener noreferrer">LifecycleRegistry<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></h3> <p>此类是「Lifecycle」库的核心类，也是<code>Lifecycle</code>抽象类的直接实现，它的作用是<strong>管理生命周期事件的派发</strong>，但是其做了非常多的优化，例如解决了产生事件时，迭代观察者过程中可能会新增或者移除观察者，用ArrayList遍历会崩的问题、新加入的观察者如何派发事件的问题，移除观察者如何更新状态的问题等等。</p> <p>这些谷歌的开发人员都帮我们解决了，只需要按下图简单配置一下即可使用：</p> <center><img src="/assets/img/lifecycle_11.d6d746a8.png" alt="lifecycle_11" style="zoom:50%;"></center> <p>可见，我们只需要按照上文提到的结构，在<code>Activity</code>中实例化一个<code>LifecycleRegistry</code>，然后在合适的生命周期回调中派发响应的事件，所有监听当前<code>Activity</code>生命周期的组件就可以获取到当前<code>Activity</code>的生命周期了。</p> <p>**需要注意的是：**上述代码仅仅是为了为你展示<code>Lifecycle</code>是如何实现生命周期事件派发的，实际使用中，并不需要为<code>Activity</code>手动派发事件，<code>ComponentActivity</code>、<code>AppcompatActivity</code>实际上已经配置好了派发逻辑，开发中直接获取<code>Lifecycle</code>即可。</p> <p>下面即将深入<code>LifecycleRegistry</code>的源码层面探究一下它的原理，但是需要注意的是，本文章的目的并不是让读者100%搞懂源码中每一行代码的运行逻辑，因为这违背了本系列文章的初衷——让读者能够在对库有足够充足的了解下开发，同时笔者也没有100%搞懂源码每一行的逻辑。</p> <p>如果读者非常有钻研精神，可以看一下这个博主的文章，他对<code>LifecycleRegistry</code>的源码做了非常详细的讲解：<a href="https://juejin.cn/post/7071144317636575262?searchId=20231009151913294FEF5A47C68C20DD18#heading-9" target="_blank" rel="noopener noreferrer">【Jetpack】学穿：Lifecycle → 生命周期 (原理篇) - 掘金 (juejin.cn)<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <p>下面我们看看LifecycleRegistry的代码脉络：</p> <center><img src="/assets/img/lifecycle_12.ad20a0e0.png" alt="lifecycle_12" style="zoom:50%;"></center> <p>笔者省去了绝大部分和业务无关的代码，只保留了最核心最精华的代码，其实被移除掉的代码都是为了解决前文中提到的“遍历过程中增删列表”、”新加入的观察者如何派发事件“等细枝末节的问题，与本文主题关系不大。</p> <p>可以看到，<code>LifecycleRegistry</code>本质上就是一个强化版的观察者模式的设计，添加观察者（observer）、遍历派发事件的模式。</p> <p>还记得上文提到的一个小问题吗，为什么<code>LifecycleOwner</code>不直接设计成接口而是以成员变量的方式挂载在对应的生命周期组件里面呢？通过<code>LifecycleRegistry</code>的源码我们可以看到，<code>LifecycleOwner</code>被以弱引用的方式存放着的，也就是说处理生命周期事件派发的<code>LifecycleRegistry</code>并不会直接引用<code>LifecycleOwner</code>，可以认为是谷歌的开发人员是为了防止产生内存泄漏而故意设计的。</p> <h3 id="_2-2-5、小总结"><a href="#_2-2-5、小总结" class="header-anchor">#</a> 2.2.5、小总结</h3> <p>我们已经依次浏览了「Lifecycle」库中的四个最核心的组件，他们的关系如果你已经搞混了，笔者再次通过一段极简的代码的方式来强化读者对他们的理解：</p> <center><img src="/assets/img/lifecycle_13.9dd03dda.png" alt="lifecycle_13" style="zoom:50%;"></center> <p>关于四个核心组件的总结：</p> <ol><li><strong><code>Lifecycle</code>描述的是存放和管理生命周期的容器</strong></li> <li><strong><code>LifecycleRegistry</code>是<code>Lifecycle</code>的实现类</strong></li> <li><strong><code>LifecycleObserver</code>是观察生命周期变化的监听器</strong></li> <li><strong><code>LifecycleOwner</code>是对外提供<code>Lifecycle</code>的提供者。</strong></li></ol> <h2 id="_3、谷歌眼中的lifecycle"><a href="#_3、谷歌眼中的lifecycle" class="header-anchor">#</a> 3、谷歌眼中的Lifecycle</h2> <h3 id="_3-1、componentactivity"><a href="#_3-1、componentactivity" class="header-anchor">#</a> 3.1、<a href="https://developer.android.com/reference/kotlin/androidx/activity/ComponentActivity" target="_blank" rel="noopener noreferrer">ComponentActivity<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></h3> <p>此类是谷歌官方基于Activity开发的子类，其集成了许多Jetpack库的核心功能，其中就包括了「Lifecycle」库，该类因此也实现了<code>LifecycleOwner</code>接口，开发者常用的<code>AppcompatActvity</code>也是该类的子类。</p> <center><img src="/assets/img/lifecycle_14.b14cdfc0.png" alt="lifecycle_14" style="zoom:50%;"></center> <p>但是细读源码会发现，该类并没有像笔者之前展示的源码那样，直接调用<code>LifecycleRegistry</code>在特定的<code>Activity</code>生命周期回调中派发事件，那么该类是如何实现生命周期事件的派发的呢？下面介绍「Lifecycle」库中的另外一个关键类：<strong>ReportFragment</strong>。</p> <h4 id="_3-1-1、reportfragment与lifecyclecallbacks"><a href="#_3-1-1、reportfragment与lifecyclecallbacks" class="header-anchor">#</a> 3.1.1、ReportFragment与LifecycleCallbacks</h4> <p>在<code>ComponentActivity</code>的onCreate()中，有一段<code>ReportFragment.injectIfNeededIn(this)</code>的代码，这个就是实现了生命周期事件派发的核心类。</p> <center><img src="/assets/img/lifecycle_15.70912793.png" alt="lifecycle_15" style="zoom:50%;"></center> <p>接下来让我们走进<code>ReportFragment</code>的源码，正如前文所述，文章并不会阐述每一行代码的原理，而是抓住主要的脉络，隐藏了和主脉络无关的代码，但是剩余的代码量仍然挺多，读者不必对大量的代码感到恐慌，因为文章会逐一解释：</p> <center><img src="/assets/img/lifecycle_16.738a55a6.png" alt="lifecycle_16" style="zoom:50%;"></center> <p>可见，<code>ReportFragment</code>做的事非常简单，就是在其生命周期的各个阶段上报生命周期事件，因为<code>Fragment</code>的生命周期和<code>Activity</code>在绝大部分是保持一致的（特殊的如<code>onCreate()</code>除外，不过也有<code>onActivityCreated()</code>、<code>onActivityPostCreated()</code>等可以感知<code>Activity</code>生命周期的函数），谷歌的开发人员于是就利用<code>ReportFragment</code>作为<strong>监听<code>Activity</code>生命周期的工具</strong>，你可以看到这个Fragment是没有UI的，这也间接证明了它的任务并不是展示一个UI而仅仅是为了监听生命周期。</p> <p>让我们回到<strong>injectIfNeedIn()</strong>，可以清楚的看到这里做了一个版本判断，如果大于api版本大于29，则使用<code>LifecycleCallbacks</code>做一个注册的逻辑，这是怎么回事呢？</p> <center><img src="/assets/img/lifecycle_17.0bb205c4.png" alt="lifecycle_17" style="zoom:50%;"></center> <p>在我提到<code>ReportFragment</code>是作为一个生命周期监听者而不是一个展示UI的模块的时候，你也许就已经隐隐约约闻到一种非常奇怪的味道。由于安卓源码设计的缺陷（只对外提供了回调方法而没有提供回调监听注册），开发者对待这一问题必须考虑向下兼容，因此他们选择了源码中已经存在的、可以监听<code>Activity</code>的生命周期的<code>Fragment</code>，但是在api 29之后，Activity原生自带了生命周期的回调监听注册，因此一旦检测到api大于或者等于29，<code>ReportFragment</code>的作用就形同虚设了，因为广播生命周期的事件的任务已经转移给<code>Activity</code>自带的生命周期回调来实现了。</p> <p>你也许还会担心，现在有<code>ReportFragment</code>和<code>Activity</code>自带的生命周期回调两种方式了，会不会导致一个事件被广播两次呢？其实不用担心，广播的时候已经做了排除了，只有api小于29的情况下，<code>ReportFragment</code>才会生效。</p> <center><img src="/assets/img/lifecycle_18.7f0e045b.png" alt="lifecycle_18" style="zoom:50%;"></center> <h3 id="_3-2、fragment"><a href="#_3-2、fragment" class="header-anchor">#</a> 3.2、Fragment</h3> <p><code>Fragment</code>本身的生命周期和<code>Activity</code>没有很大的差异，依然是内置<code>LifecycleRegistry</code>然后在合适的生命周期回调中广播生命周期事件的一套，但是值得注意的是：</p> <blockquote><p>当<code>Fragment</code>被<code>FragmentManager</code>管理时，例如执行<code>replace()</code>事务中，逻辑上当前的<code>Fragment</code>只是被另外一个同类所替换了，它并没有真的被销毁（因为待会还有重新回来的机会），因此该<code>Fragment</code>并不会执行<code>onDestroy()</code>，然而由于内存上的考量，不可见的<code>Fragment</code>的<code>View</code>理应被回收，因此<code>View</code>会被销毁。</p> <p>换句话说，<code>Fragment</code>不可见之后，它的状态会保存起来，但是其<code>View</code>会被销毁，待会再次可见的时候，会根据其状态再一次执行<strong>onCreateView()</strong>。</p></blockquote> <p>上述机制导致了一个问题：<code>Fragment</code>的生命周期和其对应的<code>View</code>的生命周期在实质上是不对等的，然而实际开发中感知生命周期大多数是为了与UI进行互动，这也导致了开发者单纯监听<code>Fragment</code>的生命周期已经不能够满足开发上的需求了。</p> <p>下面这张来源于谷歌官方开发者文档的图片很好的诠释了<code>Fragment</code>和它的<code>View</code>的生命周期关系：</p> <img src="https://developer.android.com/static/images/guide/fragments/fragment-view-lifecycle.png?hl=zh-cn" alt="Fragment生命周期" style="zoom:50%;"> <p>假如一个<code>Fragment</code>正在栈顶，他会处于Resumed的阶段，但是被replace之后（或者说是进入了回退栈），它会进入Created阶段，此刻<code>View</code>被销毁，<code>View</code>会进入Destroyed阶段，但是<code>Fragment</code>重回栈顶的时候，<code>Fragment</code>会从Created再次回归到Resume，而<code>View</code>会从Destroyed重回Resumed状态。</p> <p>换句话说，在<code>Fragment</code>的生命周期中，它的View可能会反复的从Destroyed到Resumed之间移动（即不断地销毁与创建）</p> <p>谷歌为了缓解这个问题，给<code>Fragment</code>的<code>View</code>单独添加了一套生命周期，我们可以通过代码看到端倪：</p> <center><img src="/assets/img/lifecycle_19.d7295861.png" alt="lifecycle_19" style="zoom:50%;"></center> <p>可以看到，在<code>Fragment</code>执行<code>performCreateView()</code>的时候，会初始化<code>View</code>的<strong>Lifecycle</strong>，两者的生命周期事件是单独通知的。</p> <ul><li>如果开发者想访问<code>Fragment</code>的生命周期，在<code>Fragment</code>中访问<code>lifecycleOwner</code>即可。</li> <li>如果开发者想访问<code>Fragment</code>的<code>View</code>的生命周期，在<code>Fragment</code>中访问<code>viewLifecycleOwner</code>即可。</li></ul> <h3 id="_3-3、viewtreelifecycleowner"><a href="#_3-3、viewtreelifecycleowner" class="header-anchor">#</a> 3.3、ViewTreeLifecycleOwner</h3> <p>在上述的代码中，能够直接访问<code>Activity</code>、<code>Fragment</code>的Lifecycle的只能是它们的类中，而很多需要访问生命周期的地方往往是一些<code>View</code>中，例如要在<code>View</code>中监听其父组件生命周期，然而<code>View</code>的父控件有非常多，包括了<code>Activity</code>、<code>Fragment</code>甚至是<code>Dialog</code>乃至更多，要想获取父组件的生命周期，只能做类型判断+类型强转的工作，这样就极大的限制了<code>View</code>的使用范围：</p> <center><img src="/assets/img/lifecycle_20.4bde3751.png" alt="lifecycle_20" style="zoom:50%;"></center> <p>为了缓解，谷歌的开发人员提出了一种叫<code>ViewTreeLifecycleOwner</code>的设计，其实这个东西并没有什么神秘的，让我们直接看看源码：</p> <center><img src="/assets/img/lifecycle_21.70c01bbd.png" alt="lifecycle_21" style="zoom:50%;"></center> <p>通篇只有两个<code>View</code>的扩展函数，第一个函数的意义是给对应的<code>View</code>绑上一个<code>LifecycleOwner</code>，第二个函数的意义是不断往上查找父控件，直到查出之前绑定的<code>LifecycleOwner</code>。</p> <p>这段源码的作用挺简单的，也就是说只要给某个顶层的控件提前绑好了<code>LifecycleOwner</code>，那么他下辖的所有子<code>View</code>都可以通过往上查找的方式来找到<code>LifecycleOwner</code>，不得不说谷歌的开发人员真的是太厉害了，在简陋的基础下做出了非常强大的功能。</p> <p>那么下面的问题是：<code>LifecycleOwner</code>的绑定发生在哪里呢？</p> <h4 id="_3-3-1、activity中的绑定"><a href="#_3-3-1、activity中的绑定" class="header-anchor">#</a> 3.3.1、Activity中的绑定</h4> <p>​	Activity的直接子类<code>ComponentActivity</code>、<code>AppcompatActivity</code>均自动完成了绑定的工作，我们以<code>ComponentActivity</code>为例看看相关的绑定代码：</p> <center><img src="/assets/img/lifecycle_22.2f8daaae.png" alt="lifecycle_22" style="zoom:50%;"></center> <p>可见在<code>ComponentActivity</code>的<code>setContentView</code>被执行时，会将<code>Activity</code>的<code>ViewLifecycleOwner</code>绑定其所在的<code>Window</code>的<code>DecorView</code>中，我们都知道<code>Activity</code>下面的所有<code>View</code>都是<code>DecorView</code>的子View，因此它们都可以直接通过谷歌开发人员提供的扩展函数直接访问到最顶层的<code>Activity</code>的<code>Lifecycle</code>。</p> <h4 id="_3-3-2、fragment中的绑定"><a href="#_3-3-2、fragment中的绑定" class="header-anchor">#</a> 3.3.2、Fragment中的绑定</h4> <p>和<code>Activity</code>类似，<code>Fragment</code>也采用了几乎一致的绑定方式，只不过是将<code>Lifecycle</code>绑定在了<code>Fragment</code>的<code>View</code>之上：</p> <center><img src="/assets/img/lifecycle_23.7909483b.png" alt="lifecycle_23" style="zoom:50%;"></center> <h4 id="_3-3-3、dialog中的绑定"><a href="#_3-3-3、dialog中的绑定" class="header-anchor">#</a> 3.3.3、Dialog中的绑定</h4> <p>默认的<code>Dialog</code>和<code>Activity</code>是不支持<code>ViewTreeLifecycleOwner</code>的，因此谷歌的开发人员重新继承实现了一个新的Dialog子类：<code>ComponentDialog</code>，其中的绑定大同小异，简单看下源码即可了解：</p> <center><img src="/assets/img/lifecycle_24.071f69fd.png" alt="lifecycle_24" style="zoom:50%;"></center> <p>看来和<code>Activity</code>一样，把<code>LifecycleOwner</code>绑定在了<code>DecorView</code>中。</p> <h4 id="_3-3-4、意义与总结"><a href="#_3-3-4、意义与总结" class="header-anchor">#</a> 3.3.4、意义与总结</h4> <p>那么谷歌的开发人员费尽心思的为以上的组件绑定<code>ViewTreeLifecycleOwner</code>有何用意呢？意义可大了，由于消除了组件之间的差异（均是通过<code>View</code>往上查找父控件直到找到<code>LifecycleOwner</code>的模式），我们不用在乎当前的<code>View</code>是在哪个控件中，都是统一通过<code>findViewTreeLifecycleOwner()</code>来获取最顶层控件的生命周期。</p> <p>例如下面的自定义View的代码，无论在上述哪个控件中都可以用：</p> <center><img src="/assets/img/lifecycle_25.8c642849.png" alt="lifecycle_25" style="zoom:50%;"></center> <p>可见，开发者只需要关注生命周期本身，不再需要担心不同组件之间的差异了。</p> <h2 id="_4、结语"><a href="#_4、结语" class="header-anchor">#</a> 4、结语</h2> <p>安卓原生的生命周期设计只能说是毛坯房都算不上的水平，然而通过「Lifecycle」库的加持之后，开发者可以轻松访问组件的生命周期，让开发业务更加的合理与安全。</p> <p>作为开发者的你，应该逐渐将重写生命周期函数的方式逐渐过渡到「Lifecycle」的开发方式中来，在一些工具类亦或者其他业务类中，你也可以使用「Lifecycle」辅助强化与生命周期相关的业务。</p> <p>如果文章帮助到你，请为笔者点一个👍🏻支持一下，你的鼓励是我前进的动力！</p> <h2 id="扩展内容"><a href="#扩展内容" class="header-anchor">#</a> 扩展内容：</h2> <h3 id="_1、maxlifecycle"><a href="#_1、maxlifecycle" class="header-anchor">#</a> 1、MaxLifecycle</h3> <p>在<code>ViewPager</code>和<code>ViewPager2</code>这类可以操作<code>Fragment</code>的框架中，存在着一个重要的特性就是离屏缓存，即<code>offscreenPageLimit</code>，这个特性的作用是在当前可见的元素两侧，缓存多少不可见的元素。</p> <p>这个机制有利于<code>ViewPager</code>在滑动过程中保持丝滑，因为当元素还未可见的时候，就提前加载并添加到视图树中。</p> <p>下图展示的就是离屏缓存为1的情况，屏幕左侧的<code>Fragment</code>提前被加载。</p> <center><img src="/assets/img/lifecycle_33.8fffa0ee.png" alt="lifecycle_33" style="zoom:50%;"></center> <p>但是这个机制却导致<code>Fragment</code>的生命周期与其可见度产生了冲突。</p> <p>对于<code>Activity</code>来说，当它进入到Resumed状态后，开发者可以轻易认为当前的<code>Activity</code>对于用户是「可见」的。但是对于处于<code>ViewPager</code>的离屏缓存区域的<code>Fragment</code>来说，虽然他们被加载出来并进入了<code>Resumed</code>状态，但是实际上用户是看不见这些<code>Fragment</code>（上图的黄色<code>Fragment</code>）。这就导致了生命周期与可见性产生了不同步的问题，毕竟<code>Resumed</code>的定义就是可以看见并可以操作的意思。</p> <p>下面简单用一个例子来演示这个问题：</p> <center><img src="/assets/img/lifecycle_27.8baca5c8.png" alt="lifecycle_27" style="zoom:50%;"></center> <p>上面的代码中虽然代码量不少，但是逻辑极其简单，就是构造一个<code>ViewPager</code>，同时带有5个<code>Fragment</code>，我们为每一个<code>Fragment</code>添加生命周期监听。</p> <center><img src="/assets/img/lifecycle_26.85523ac1.jpg" alt="lifecycle_26" style="zoom:50%;"></center> <p>当初次进入的时候，<code>ViewPager</code>处于第1个位置，但是我们看一下日志：</p> <blockquote><p>当前位置:0进入了ON_CREATE</p> <p>当前位置:0进入了ON_START</p> <p>当前位置:1进入了ON_CREATE</p> <p>当前位置:0进入了ON_RESUME</p> <p>当前位置:1进入了ON_START</p> <p>当前位置:1进入了ON_RESUME</p></blockquote> <p>可以看见的是，虽然当前只有第1个位置的<code>Fragment</code>可见，然而第2个位置的<code>Fragment</code>却进入了<code>onResume</code>，这个就是上面提到的离屏缓存的机制导致的。这导致在业务上我们没办法单纯通过<code>Fragment</code>的生命周期来判断是否被用户可见。</p> <p>对于这个问题，谷歌为<code>Fragment</code>增加了一个<code>setUserVisibleHint(Boolean)</code>的方法来解决上述的问题。开发者可以手动通过调用这个方法来修改<code>Fragment</code>的可见度。需要注意的是，这个机制只是一个简单的「标记」，它并不能实际决定<code>Fragment</code>是否对于用户可见。</p> <p>于是<code>ViewPager</code>在页面跳转的时候，会主动去修改那些<code>Fragment</code>的<code>UserVisibleHint</code>，开发者则可以根据这个值来判断<code>Fragment</code>是否可见。</p> <p>长期以来，开发者确实能够使用这个机制去解决<code>ViewPager</code>场景下的可见度问题。</p> <p>但是复盘之后可以发现，这个简单的标记位也有不少缺陷：</p> <ul><li>缺乏统一的访问入口，子控件难以取值</li> <li>与生命周期原本的设计产生偏移，增加维护难度</li> <li>难以监听</li></ul> <p>于是谷歌在新版的<code>Fragment</code>中，对源码进行了优化，增加了一个「MaxLifecycle」的机制。</p> <p>一直以来，<code>Fragment</code>的生命周期都是没法直接设置的，只能通过<code>FragmentManager</code>对<code>Fragment</code>进行操作来间接控制，虽然「MaxLifecycle」也没法直接控制，但是给<code>Fragment</code>的生命周期控制增加了一层约束。</p> <p>如果理解「MaxLifecycle」呢？简单来说就是最大的生命周期。</p> <blockquote><p>还记得生命周期是有大小的吗？它们从Created、Started、Resumed依次增大。</p></blockquote> <p>如果开发者把某个<code>Fragment</code>的最大生命周期设置为Started，这意味着此<code>Fragment</code>永远不会到达Resumed，哪怕它满足了原本应该到达Resumed的条件，而是最多停留在Started。</p> <p>我们看看如果使用「MaxLifecycle」这个机制的简单使用：</p> <center><img src="/assets/img/lifecycle_28.91a1421b.png" alt="lifecycle_28" style="zoom:50%;"></center> <p>和传统的<code>FragmentManager</code>一样，开发者只需要在commit之前，额外调用<code>setMaxLifecycle()</code>即可。</p> <p>依照上图的设置之后，哪怕新添加的<code>Fragment</code>马上可见了，他的生命周期也只会停留在Started。</p> <p><strong>MaxLifecycle对解决ViewPager导致的Fragment的可见性问题有什么实际性意义呢？</strong></p> <p>意义非常重大，我们复盘一下导致这个问题的原因：</p> <ul><li>当<code>Fragment</code>被<code>ViewPager</code>通过<code>FragmentManager</code>加入到视图树中时，在可见的<code>Fragment</code>两侧（实际就是屏幕意外）会因为离屏缓存的机制存在「用户不可见，但是进入了Resumed」的<code>Fragment</code>。</li></ul> <p>因此问题的根源就是<code>Fragment</code>在用户仍为看到它的时候就”提前“进入了Resumed，如果我们能够让它不可见的时候，限制在Started，那问题不就解决了么？</p> <p>实际上<code>ViewPager</code>就是这样做的，在新版<code>ViewPager</code>中适配了这个机制：</p> <center><img src="/assets/img/lifecycle_30.254c1ba7.png" alt="lifecycle_30" style="zoom:50%;"></center> <p><code>ViewPager</code>的常用Adapter之一<code>FragmentStatePagerAdapter</code>可以看到，新增了一个构造函数，可以传入Behavior：</p> <ul><li><code>BEHAVIOR_SET_USER_VISIBLE_HINT</code>：原版Adapter的行为，<code>Fragment</code>在用户可见与不可见状态切换时，将调用<code>Fragment</code>的<code>setUserVisibleHint(Boolean)</code>来修改可见标记。</li> <li><code>BEHAVIOR_RESUME_ONLY_CURRENT_FRAGMENT</code>：新版行为，使用<code>setMaxLifecycle(Fragment,Lifecycle.State)</code>来限制<code>Fragment</code>的最大生命周期。当<code>Fragment</code>处于<code>ViewPager</code>的不可见状态时，最大生命周期限制为Started。</li></ul> <p>我们从代码中可以看出端倪：</p> <center><img src="/assets/img/lifecycle_31.4a237f07.png" alt="lifecycle_31" style="zoom:50%;"></center> <p><code>setPrimaryItem()</code>是<code>PagerAdapter</code>切换Item的核心方法，每次切换Item的时候，Adapter先是「将之前显示的<code>Fragment</code>设置为不可见」，然后「将即将显示的<code>Fragment</code>设置为可见」。</p> <p>但是设置的手段却不一样，从代码中看出，不同的Behavior有不同的设置手段，新版是通过设置MaxLifecycle，而旧版则是之前的VisibleHint。</p> <p>因此，开发者只需要在使用ViewPager的时候，构建Adapter时将Behavior改为新版即可。</p> <blockquote><p>只有ViewPager需要单独设置，对于ViewPager2来说并不需要额外设置，它默认就是新版的MaxLifecycle机制。</p></blockquote> <p>回到一开始的代码，调用<code>FragmentStatePagerAdapter</code>的第二个构造函数，将Behavior改为新版。</p> <center><img src="/assets/img/lifecycle_32.515e2bf0.png" alt="lifecycle_32" style="zoom:50%;"></center> <p>可以预期的是，在设置后，处于不可见状态的<code>Fragment</code>将不会进入Resumed状态，大致情况如下图所示：</p> <center><img src="/assets/img/lifecycle_34.cef872be.png" alt="lifecycle_34" style="zoom:50%;"></center> <p>日志如下：</p> <blockquote><p>当前位置:0进入了ON_CREATE</p> <p>当前位置:0进入了ON_START</p> <p>当前位置:1进入了ON_CREATE</p> <p>当前位置:1进入了ON_START</p> <p>当前位置:0进入了ON_RESUME</p></blockquote> <p>初始状态下，用户看到的是第1个<code>Fragment</code>，由于离屏缓存的机制，第2个<code>Fragment</code>也被加载并纳入视图树了，但是由于它被<code>ViewPager</code>设置了MaxLifecycle为Started，因此<code>ViewPager</code>在没有发生移动的情况下，它的生命周期被限制在了Started。</p> <p>滑动ViewPager至第2页，我们再观察日志：</p> <blockquote><p>当前位置:2进入了ON_CREATE</p> <p>当前位置:2进入了ON_START</p> <p>当前位置:0进入了ON_PAUSE</p> <p>当前位置:1进入了ON_RESUME</p></blockquote> <p>第1个<code>Fragment</code>由于不可见，进入了Paused，第2个<code>Fragment</code>由于滑动导致可见了，从Started变为了Resumed。</p> <p>为什么第3个<code>Fragment</code>也会发生生命周期变化呢，其实就是离屏缓存在起作用，同时MaxLifecycle也发挥了作用，此刻它的生命周期被限制在了Started。</p> <p>在使用了MaxLifecycle之后，开发者可以统一使用生命周期来管理<code>Fragment</code>的首次加载，代码如下：</p> <center><img src="/assets/img/lifecycle_35.e06abf61.png" alt="lifecycle_35" style="zoom:50%;"></center> <p><strong>总结：自此关于MaxLifecycle的作用已经全部讲解完毕了，通过设置MaxLifecycle开发者可以避免Fragment出现生命周期与实际可见不一致的问题，而官方提供的ViewPager已经默认实现，非常的方便。</strong></p></div></section> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev"><a href="/" class="prev router-link-active">
          简介
        </a></span> <span class="next"><a href="/blogs/状态保存.html">
          状态保存与SavedState
        </a></span></p></div> <div class="comments-wrapper"><!----></div></main></div> <!----></div> <ul class="sub-sidebar sub-sidebar-wrapper" style="width:12rem;" data-v-b57cc07c data-v-7dd95ae2><li class="level-2" data-v-b57cc07c><a href="/blogs/%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.html#_1-1、前世-初识篇" class="sidebar-link reco-side-_1-1、前世-初识篇" data-v-b57cc07c>1.1、前世——初识篇</a></li><li class="level-2" data-v-b57cc07c><a href="/blogs/%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.html#_1-2、前世-详解篇" class="sidebar-link reco-side-_1-2、前世-详解篇" data-v-b57cc07c>1.2、前世——详解篇</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.html#_1-2-1、oncreate-、ondestroy" class="sidebar-link reco-side-_1-2-1、oncreate-、ondestroy" data-v-b57cc07c>1.2.1、onCreate()、onDestroy()</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.html#_1-2-2、onstart-、onstop" class="sidebar-link reco-side-_1-2-2、onstart-、onstop" data-v-b57cc07c>1.2.2、onStart()、onStop()</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.html#_1-2-3、onresume-、onpause" class="sidebar-link reco-side-_1-2-3、onresume-、onpause" data-v-b57cc07c>1.2.3、onResume()、onPause()</a></li><li class="level-2" data-v-b57cc07c><a href="/blogs/%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.html#_1-3、前世-总结篇" class="sidebar-link reco-side-_1-3、前世-总结篇" data-v-b57cc07c>1.3、前世——总结篇</a></li><li class="level-2" data-v-b57cc07c><a href="/blogs/%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.html#_2-1、今生-初识篇" class="sidebar-link reco-side-_2-1、今生-初识篇" data-v-b57cc07c>2.1、今生——初识篇</a></li><li class="level-2" data-v-b57cc07c><a href="/blogs/%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.html#_2-2、今生-详解篇" class="sidebar-link reco-side-_2-2、今生-详解篇" data-v-b57cc07c>2.2、今生——详解篇</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.html#_2-2-1、lifecycle" class="sidebar-link reco-side-_2-2-1、lifecycle" data-v-b57cc07c>2.2.1、Lifecycle</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.html#_2-2-2、lifecycleowner" class="sidebar-link reco-side-_2-2-2、lifecycleowner" data-v-b57cc07c>2.2.2、LifecycleOwner</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.html#_2-2-3、lifecycleobserver" class="sidebar-link reco-side-_2-2-3、lifecycleobserver" data-v-b57cc07c>2.2.3、LifecycleObserver</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.html#_2-2-4、lifecycleregistry" class="sidebar-link reco-side-_2-2-4、lifecycleregistry" data-v-b57cc07c>2.2.4、LifecycleRegistry</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.html#_2-2-5、小总结" class="sidebar-link reco-side-_2-2-5、小总结" data-v-b57cc07c>2.2.5、小总结</a></li><li class="level-2" data-v-b57cc07c><a href="/blogs/%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.html#_3、谷歌眼中的lifecycle" class="sidebar-link reco-side-_3、谷歌眼中的lifecycle" data-v-b57cc07c>3、谷歌眼中的Lifecycle</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.html#_3-1、componentactivity" class="sidebar-link reco-side-_3-1、componentactivity" data-v-b57cc07c>3.1、ComponentActivity</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.html#_3-2、fragment" class="sidebar-link reco-side-_3-2、fragment" data-v-b57cc07c>3.2、Fragment</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.html#_3-3、viewtreelifecycleowner" class="sidebar-link reco-side-_3-3、viewtreelifecycleowner" data-v-b57cc07c>3.3、ViewTreeLifecycleOwner</a></li><li class="level-2" data-v-b57cc07c><a href="/blogs/%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.html#_4、结语" class="sidebar-link reco-side-_4、结语" data-v-b57cc07c>4、结语</a></li><li class="level-2" data-v-b57cc07c><a href="/blogs/%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.html#扩展内容" class="sidebar-link reco-side-扩展内容" data-v-b57cc07c>扩展内容：</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.html#_1、maxlifecycle" class="sidebar-link reco-side-_1、maxlifecycle" data-v-b57cc07c>1、MaxLifecycle</a></li></ul></div></div></div><div class="global-ui"><div class="back-to-ceiling" style="right:1rem;bottom:6rem;width:2.5rem;height:2.5rem;border-radius:.25rem;line-height:2.5rem;display:none;" data-v-c6073ba8 data-v-c6073ba8><svg t="1574745035067" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="5404" class="icon" data-v-c6073ba8><path d="M526.60727968 10.90185116a27.675 27.675 0 0 0-29.21455937 0c-131.36607665 82.28402758-218.69155461 228.01873535-218.69155402 394.07834331a462.20625001 462.20625001 0 0 0 5.36959153 69.94390903c1.00431239 6.55289093-0.34802892 13.13561351-3.76865779 18.80351572-32.63518765 54.11355614-51.75690182 118.55860487-51.7569018 187.94566865a371.06718723 371.06718723 0 0 0 11.50484808 91.98906777c6.53300375 25.50556257 41.68394495 28.14064038 52.69160883 4.22606766 17.37162448-37.73630017 42.14135425-72.50938081 72.80769204-103.21549295 2.18761121 3.04276886 4.15646224 6.24463696 6.40373557 9.22774369a1871.4375 1871.4375 0 0 0 140.04691725 5.34970492 1866.36093723 1866.36093723 0 0 0 140.04691723-5.34970492c2.24727335-2.98310674 4.21612437-6.18497483 6.3937923-9.2178004 30.66633723 30.70611158 55.4360664 65.4791928 72.80769147 103.21549355 11.00766384 23.91457269 46.15860503 21.27949489 52.69160879-4.22606768a371.15156223 371.15156223 0 0 0 11.514792-91.99901164c0-69.36717486-19.13165746-133.82216804-51.75690182-187.92578088-3.42062944-5.66790279-4.76302748-12.26056868-3.76865837-18.80351632a462.20625001 462.20625001 0 0 0 5.36959269-69.943909c-0.00994388-166.08943902-87.32547796-311.81420293-218.6915546-394.09823051zM605.93803103 357.87693858a93.93749974 93.93749974 0 1 1-187.89594924 6.1e-7 93.93749974 93.93749974 0 0 1 187.89594924-6.1e-7z" p-id="5405" data-v-c6073ba8></path><path d="M429.50777625 765.63860547C429.50777625 803.39355007 466.44236686 1000.39046097 512.00932183 1000.39046097c45.56695499 0 82.4922232-197.00623328 82.5015456-234.7518555 0-37.75494459-36.9345906-68.35043303-82.4922232-68.34111062-45.57627738-0.00932239-82.52019037 30.59548842-82.51086798 68.34111062z" p-id="5406" data-v-c6073ba8></path></svg></div></div></div>
    <script src="/assets/js/app.a2aee210.js" defer></script><script src="/assets/js/7.83b45c61.js" defer></script><script src="/assets/js/2.4e1717d6.js" defer></script><script src="/assets/js/1.448f1724.js" defer></script><script src="/assets/js/14.a39c521a.js" defer></script>
  </body>
</html>
