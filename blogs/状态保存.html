<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>状态保存与SavedState | 安卓现代化开发指南</title>
    <meta name="generator" content="VuePress 1.9.10">
    <link rel="icon" href="/modern_android_logo.png">
    <meta name="description" content="这里提供安卓现代化开发参考文档，适合新手和进阶开发。">
    
    <link rel="preload" href="/assets/css/0.styles.5b9cc425.css" as="style"><link rel="preload" href="/assets/js/app.a2aee210.js" as="script"><link rel="preload" href="/assets/js/7.83b45c61.js" as="script"><link rel="preload" href="/assets/js/2.4e1717d6.js" as="script"><link rel="preload" href="/assets/js/1.448f1724.js" as="script"><link rel="preload" href="/assets/js/15.b5939b09.js" as="script"><link rel="prefetch" href="/assets/js/10.06a373d0.js"><link rel="prefetch" href="/assets/js/11.266dbd4f.js"><link rel="prefetch" href="/assets/js/14.a39c521a.js"><link rel="prefetch" href="/assets/js/16.3a23acb4.js"><link rel="prefetch" href="/assets/js/17.490c51cf.js"><link rel="prefetch" href="/assets/js/18.eda269f5.js"><link rel="prefetch" href="/assets/js/19.61278165.js"><link rel="prefetch" href="/assets/js/20.3eff384d.js"><link rel="prefetch" href="/assets/js/21.e88efa15.js"><link rel="prefetch" href="/assets/js/22.4e8fd7d4.js"><link rel="prefetch" href="/assets/js/23.fcde4691.js"><link rel="prefetch" href="/assets/js/24.b7ea5092.js"><link rel="prefetch" href="/assets/js/25.783749da.js"><link rel="prefetch" href="/assets/js/26.7022c712.js"><link rel="prefetch" href="/assets/js/27.b201cbd1.js"><link rel="prefetch" href="/assets/js/28.b996e086.js"><link rel="prefetch" href="/assets/js/29.fd0bdf51.js"><link rel="prefetch" href="/assets/js/3.e0c20fb4.js"><link rel="prefetch" href="/assets/js/30.7e183c05.js"><link rel="prefetch" href="/assets/js/31.364e9117.js"><link rel="prefetch" href="/assets/js/32.0ce788fa.js"><link rel="prefetch" href="/assets/js/33.a0652f64.js"><link rel="prefetch" href="/assets/js/34.2e8cbc55.js"><link rel="prefetch" href="/assets/js/35.77af379f.js"><link rel="prefetch" href="/assets/js/36.58d58b5d.js"><link rel="prefetch" href="/assets/js/37.8e790ffe.js"><link rel="prefetch" href="/assets/js/38.22572e4e.js"><link rel="prefetch" href="/assets/js/39.33d87db9.js"><link rel="prefetch" href="/assets/js/4.9374ab88.js"><link rel="prefetch" href="/assets/js/40.053e530f.js"><link rel="prefetch" href="/assets/js/41.4a7b5ec5.js"><link rel="prefetch" href="/assets/js/5.bfc822b3.js"><link rel="prefetch" href="/assets/js/6.c6a52294.js"><link rel="prefetch" href="/assets/js/8.d751b2d9.js"><link rel="prefetch" href="/assets/js/9.9f743a74.js"><link rel="prefetch" href="/assets/js/vendors~docsearch.b33fc384.js">
    <link rel="stylesheet" href="/assets/css/0.styles.5b9cc425.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container" data-v-7dd95ae2><div data-v-7dd95ae2><div class="password-shadow password-wrapper-out" style="display:none;" data-v-59e6cb88 data-v-7dd95ae2 data-v-7dd95ae2><h3 class="title" data-v-59e6cb88>安卓现代化开发指南</h3> <p class="description" data-v-59e6cb88>这里提供安卓现代化开发参考文档，适合新手和进阶开发。</p> <label id="box" class="inputBox" data-v-59e6cb88><input type="password" value="" data-v-59e6cb88> <span data-v-59e6cb88>Konck! Knock!</span> <button data-v-59e6cb88>OK</button></label> <div class="footer" data-v-59e6cb88><span data-v-59e6cb88><i class="iconfont reco-theme" data-v-59e6cb88></i> <a target="blank" href="https://vuepress-theme-reco.recoluan.com" data-v-59e6cb88>vuePress-theme-reco</a></span> <span data-v-59e6cb88><i class="iconfont reco-copyright" data-v-59e6cb88></i> <a data-v-59e6cb88><!---->
          
        <!---->
        2023
      </a></span></div></div> <div class="hide" data-v-7dd95ae2><header class="navbar" data-v-7dd95ae2><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">安卓现代化开发指南</span></a> <div class="links"><div class="color-picker"><a class="color-button"><i class="iconfont reco-color"></i></a> <div class="color-picker-menu" style="display:none;"><div class="mode-options"><h4 class="title">Choose mode</h4> <ul class="color-mode-options"><li class="dark">dark</li><li class="auto active">auto</li><li class="light">light</li></ul></div></div></div> <!----> <nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link"><i class="undefined"></i>
  首页
</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="undefined"></i>
      晴天小庭
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="https://juejin.cn/user/114798491603527" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="undefined"></i>
  掘金主页
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul></div></div> <!----></nav></div></header> <div class="sidebar-mask" data-v-7dd95ae2></div> <aside class="sidebar" data-v-7dd95ae2><div class="personal-info-wrapper" data-v-1fad0c41 data-v-7dd95ae2><!----> <!----> <div class="num" data-v-1fad0c41><div data-v-1fad0c41><h3 data-v-1fad0c41>4</h3> <h6 data-v-1fad0c41>Articles</h6></div> <div data-v-1fad0c41><h3 data-v-1fad0c41>0</h3> <h6 data-v-1fad0c41>Tags</h6></div></div> <ul class="social-links" data-v-1fad0c41></ul> <hr data-v-1fad0c41></div> <nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link"><i class="undefined"></i>
  首页
</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title"><i class="undefined"></i>
      晴天小庭
    </span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="https://juejin.cn/user/114798491603527" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="undefined"></i>
  掘金主页
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul></div></div> <!----></nav> <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><a href="/" class="sidebar-heading clickable router-link-active"><span>欢迎学习</span> <!----></a> <ul class="sidebar-links sidebar-group-items"><li><a href="/" aria-current="page" class="sidebar-link">简介</a></li></ul></section></li><li><section class="sidebar-group collapsable depth-0"><a href="/blogs/生命周期" class="sidebar-heading clickable open"><span>学习目录</span> <span class="arrow down"></span></a> <ul class="sidebar-links sidebar-group-items"><li><a href="/blogs/生命周期.html" class="sidebar-link">生命周期与Lifecycle</a></li><li><a href="/blogs/状态保存.html" class="active sidebar-link">状态保存与SavedState</a></li><li><a href="/blogs/ViewModel.html" class="sidebar-link">传世不朽ViewModel</a></li></ul></section></li></ul> </aside> <div class="password-shadow password-wrapper-in" style="display:none;" data-v-59e6cb88 data-v-7dd95ae2><h3 class="title" data-v-59e6cb88>状态保存与SavedState</h3> <!----> <label id="box" class="inputBox" data-v-59e6cb88><input type="password" value="" data-v-59e6cb88> <span data-v-59e6cb88>Konck! Knock!</span> <button data-v-59e6cb88>OK</button></label> <div class="footer" data-v-59e6cb88><span data-v-59e6cb88><i class="iconfont reco-theme" data-v-59e6cb88></i> <a target="blank" href="https://vuepress-theme-reco.recoluan.com" data-v-59e6cb88>vuePress-theme-reco</a></span> <span data-v-59e6cb88><i class="iconfont reco-copyright" data-v-59e6cb88></i> <a data-v-59e6cb88><!---->
          
        <!---->
        2023
      </a></span></div></div> <div data-v-7dd95ae2><div data-v-7dd95ae2><main class="page"><section style="display:;"><div class="page-title"><h1 class="title">状态保存与SavedState</h1> <div data-v-8a445198><i class="iconfont reco-account" data-v-8a445198><span data-v-8a445198>晴天小庭</span></i> <i class="iconfont reco-date" data-v-8a445198><span data-v-8a445198>10/25/2023</span></i> <!----> <!----></div></div> <div class="theme-reco-content content__default"><h1 id="状态保存"><a href="#状态保存" class="header-anchor">#</a> 状态保存</h1> <h2 id="_1、为什么需要状态保存"><a href="#_1、为什么需要状态保存" class="header-anchor">#</a> 1、为什么需要状态保存？</h2> <p>说「状态保存」之前，我们先讲一讲为什么需要状态保存：</p> <p>常见的window、linux系统不同的是，移动端的操作系统拥有的内存更少，因此这类系统更容易面临<strong>内存不足</strong>的情况，如何最大限度利用较少的内存是移动端操作系统比较重要的问题。</p> <p>对于安卓系统来说，一个<code>Activity</code>不可见时，即这时已经跳转到了另外一个<code>Activity</code>或者整个App都处于处于后台的情况下，同时它的生命周期处于「Stoped」。在这之后，一旦出现内存不足的情况，Android系统就会考虑销毁这些用户不可见的<code>Activity</code>，这样就可以释放它们占用的内存，给予用户目前正在交互的<code>Activity</code>更多的内存，避免彻底的OOM（out of momory)异常出现。</p> <p>此刻就出现了一个问题，如果只是单纯的把<code>Activity</code>销毁了，那么之前用户操作的信息就全部丢失了，可以想象的一个场景是：用户正在编辑一段日记的时候，来了一个电话，当通话结束之后（假设此刻处于后台的编辑日记的Activity由于内存不足被销毁了），那么返回到App的时候，用户会发现花了很多时间编辑的日记已经全部丢失，这样的App逻辑是无法接受的。因此我们需要一种机制：在即将被销毁的时候保存<code>Activity</code>的状态，页面重建之后根据之前保存的状态恢复页面，这种“机制”就是标题所谓的「状态保存」。</p> <h2 id="_2、状态在安卓中意味着什么"><a href="#_2、状态在安卓中意味着什么" class="header-anchor">#</a> 2、状态在安卓中意味着什么</h2> <p>在安卓中，当我们提到「状态保存」的时候，开发者保存的状态其实就是某些「成员变量」。</p> <p>因此，读者可以简单的理解为，当一个变量存在于View中，即此变量为View的成员变量时，此变量可能会由于View的重建而丢失，因为View此时是一个全新的实例。同理，当Activity与Fragment也会存在类似的场景丢失他们的成员变量。因此开发者需要处理这些可能会由于实例的替换导致丢失成员变量的场景，这个处理的过程就是安卓的「状态保存」。</p> <p>下面结合代码理解一下：</p> <h4 id="_2-1、view的实例状态"><a href="#_2-1、view的实例状态" class="header-anchor">#</a> 2.1、View的实例状态</h4> <center><img src="/assets/img/savedstate_04.b51d3efd.png" alt="savedstate_04" style="zoom:67%;"></center> <p>根据上文所述<code>View</code>中的那些成员变量就是「View的实例状态」，这里展示一个按钮案例，常见的按钮就有”选中“和”未选中“两个状态，因此开发者会用一个布尔值来存储这个状态，但是由于重建机制的存在，<code>View</code>会被一个新的实例代替，那么此时的View就丢失了状态了。</p> <h4 id="_2-2、activity的实例状态"><a href="#_2-2、activity的实例状态" class="header-anchor">#</a> 2.2、Activity的实例状态</h4> <center><img src="/assets/img/savedstate_05.22601a3e.png" alt="savedstate_05" style="zoom:67%;"></center> <p>一个<code>Activity</code>中存在着<code>View</code>，在<code>View</code>的内部存在着「View的实例状态」，同时它旁边也存在着一些<code>Activity</code>的成员变量，这些成员变量和<code>View</code>内部的状态共同组成了「<code>Activity</code>的实例状态」。</p> <p>同样，当遇到重建的场景时，<code>Activity</code>会同时丢失自身的状态与<code>View</code>内部的实例状态（在<code>View</code>没有实现状态保存的情况下）。</p> <h4 id="_2-3、fragment的实例状态"><a href="#_2-3、fragment的实例状态" class="header-anchor">#</a> 2.3、Fragment的实例状态</h4> <center><img src="/assets/img/savedstate_06.2af77d93.png" alt="savedstate_06" style="zoom:67%;"></center> <p>与<code>Activity</code>几乎类似，<code>Fragment</code>也同样存在着<code>View</code>与自身的成员变量，因此「<code>View</code>的实例状态」与这些成员变量共同组成了「Fragment的实例状态」。</p> <blockquote><p>需要注意的是：由于<code>Fragment</code>的特殊性，<code>Fragment</code>的生命周期与<code>Fragment</code>的<code>View</code>的生命周期是不一致的，一个<code>Fragment</code>在自身的生命周期内可能会跨越多个<code>View</code>的重建，这也导致了<code>Fragment</code>的状态保存分裂为「成员变量的保存」与「View的实例状态的保存」，这两者在<code>Activity</code>中是同时发生的，而<code>Fragment</code>中并不一定同时。</p></blockquote> <h4 id="_2-4、实例状态的包含关系"><a href="#_2-4、实例状态的包含关系" class="header-anchor">#</a> 2.4、实例状态的包含关系</h4> <p>由于<code>View</code>是依附于组件中的，因此「组件的实例状态」除了组件本身的变量，还包括了「<code>View</code>的实例状态」，因此当我们说组件的状态保存的时候，其实还包括了保存<code>View</code>的状态。</p> <p>也许读者此时会联想到，<code>Fragment</code>也可以存在于父<code>Fragment</code>或者父<code>Activity</code>，那么它们之间的实例状态也是包含关系吗？</p> <p>答案是对的，当<code>Activity</code>保存自身状态的时候，同时也会让它所包含的<code>Fragment</code>保存实例状态。</p> <p>下面这张图可以展示状态关系：</p> <center><img src="/assets/img/savedstate_07.a7c7c892.png" alt="savedstate_07" style="zoom:67%;"></center> <h2 id="_3、图示状态保存与恢复"><a href="#_3、图示状态保存与恢复" class="header-anchor">#</a> 3、图示状态保存与恢复</h2> <p>下面援引自<a href="https://inthecheesefactory.com/blog/fragment-state-saving-best-practices/en" target="_blank" rel="noopener noreferrer">The Real Best Practices to Save<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>的几张图可以很好阐述状态保存时发生的事情：</p> <blockquote><p>当Activity需要保存实例状态的时候，它会先遍历所有的View让他们各自保存自己的状态，然后打包放在自己的实例状态中的某个地方，和自身的其他业务状态保存在一起。</p></blockquote> <center><img src="https://inthecheesefactory.com/uploads/source/fragmentstate/activitysavestate_.gif" style="zoom:67%;"></center> <blockquote><p>相反，当Activity需要恢复状态的时候，它会从实例状态中找出所有View之前保存的状态，然后将他们恢复给所有的View，同时恢复自身的业务状态。</p></blockquote> <center><img src="https://inthecheesefactory.com/uploads/source/fragmentstate/activityrestorestate_.gif" style="zoom:67%;"></center> <p>对于<code>Fragment</code>来说整个过程是类似的，这里就不展示了。</p> <h2 id="_4、实操状态保存与恢复"><a href="#_4、实操状态保存与恢复" class="header-anchor">#</a> 4、实操状态保存与恢复</h2> <h3 id="_4-1、view"><a href="#_4-1、view" class="header-anchor">#</a> 4.1、View</h3> <p><code>View</code>的状态保存与恢复核心方法是<code>onSaveInstanceState()</code>与<code>onRestoreInstanceState()</code>。</p> <p>开发者只需要为当前的<code>View</code>在<code>onSaveInstanceState()</code>、<code>onRestoreInstanceState()</code>中实现图中的操作即可。</p> <center><img src="/assets/img/savedstate_13.d3a451cc.png" alt="savedstate_13" style="zoom:67%;"></center> <p>需要注意的是：</p> <blockquote><p>View能够实现状态保存与恢复的前提是：必须在UI树中存在唯一的ID。</p></blockquote> <p>换句话说，这要求了开发者必须在布局的xml中为该View赋予唯一的ID，或者动态添加的时候生成一个唯一ID。</p> <p>这并不难理解，状态保存的本质是将状态缓存在某个容器中，需要恢复的时候从容器中取出来，而ID则是取的Key，如果没有Key那又如何保存状态呢？</p> <h3 id="_4-2、activity"><a href="#_4-2、activity" class="header-anchor">#</a> 4.2、Activity</h3> <p><code>Activity</code>的状态保存与<code>View</code>类似，也是一对<code>onSaveInstanceState()</code>与<code>onRestoreInstanceState()</code>方法，但是开发者大多数选择在<code>onCreate()</code>中恢复状态，这取决于实际的需要。</p> <center><img src="/assets/img/savedstate_14.b15bf8e1.png" alt="savedstate_14" style="zoom:67%;"></center> <h3 id="_4-3、fragment"><a href="#_4-3、fragment" class="header-anchor">#</a> 4.3、Fragment</h3> <p><code>Fragment</code>的状态保存也与<code>Activity</code>类似，下面直接看图即可：</p> <center><img src="/assets/img/savedstate_15.469a1c57.png" alt="savedstate_15" style="zoom:67%;"></center> <blockquote><p>依然需要注意的是：在2.3中提到，由于Fragment的实例与UI的分离的设计模式，因此会发生只保存UI状态的情况，因此上图中的onSaveInstanceState()是不会调用的，我们从方法名中也可以看出这是保存实例状态。</p></blockquote> <h2 id="_5、状态保存与恢复的时机"><a href="#_5、状态保存与恢复的时机" class="header-anchor">#</a> 5、状态保存与恢复的时机？</h2> <h3 id="_5-1、activity"><a href="#_5-1、activity" class="header-anchor">#</a> 5.1、Activity</h3> <blockquote><p>当<code>Activity</code>被意外销毁时，需要保存状态，并在Activity重新恢复显示时恢复状态。</p></blockquote> <p>对于<code>Activity</code>来说，除了用户手动从当前<code>Activity</code>退出以外（这种情况无需状态保存），还有以下两种情况会导致<code>Activity</code>会被系统销毁：</p> <blockquote><ol><li>配置发生变化（用户修改了手机的语言、暗夜模式等）。</li> <li>Activity处于「停止」状态时因系统限制（内存不足）而被销毁。</li></ol></blockquote> <p>为什么用户主动按下返回按钮导致<code>Activity</code>销毁不需要状态保存而后两种情况需要状态保存呢？</p> <p>主要的原因是前者是**「用户意料之内的行为」<strong>，而后两种情况属于</strong>「用户意料之外的行为」**。当一个用户旋转一个页面时，亦或者用户从页面A跳转到B，并稍后从B返回到A时，这两种情况用户并不希望页面的信息丢失了，否则就会出现上文出现的「编辑一半的日记被来电清空」的特殊情况，这对于用户来说是不可以接受的。</p> <p>下面结合一张图来展示<code>Activity</code>生命周期与状态保存的关系：</p> <center><img src="/assets/img/savedstate_11.a0236a37.png" alt="savedstate_11" style="zoom:100%;"></center> <p>由图中可见，<code>Activity</code>的状态保存与恢复发生在<code>onSaveInstanceState()</code>和<code>onRestoreInstanceState()</code>中，具体的细节下文会解释，这里读者记住它发生的时机即可。（在安卓9之后，保存状态发生在onStop()之后，这与安卓9之前的版本有细微的差异）。</p> <h3 id="_5-2、fragment"><a href="#_5-2、fragment" class="header-anchor">#</a> 5.2、Fragment</h3> <blockquote><p><code>Fragment</code>保存状态的时机相对复杂，有好几种情况。同时保存业务状态和保存View的状态的时机并不一定是一致的。</p></blockquote> <p>下面援引官方文档的一句结论：</p> <blockquote><p><strong>注意</strong>：仅当 fragment 的宿主 activity 调用自己的 <code>onSaveInstanceState(Bundle)</code> 时，系统才会调用 <code>onSaveInstanceState(Bundle)</code>。</p></blockquote> <p>实际上这个结论并不能完全概括<code>Fragment</code>保存状态的所有时机，只是阐述了其中一种由<code>Activity</code>发生状态保存的时候，顺便保存其子<code>Fragment</code>状态的情况，而<code>Fragment</code>保存状态的情况还有两种，笔者下文会讲，这里先从<code>Activity</code>发生状态保存时开始讲起。</p> <h4 id="_5-2-1、activity状态保存时-顺便保存fragment的状态-恢复状态同理"><a href="#_5-2-1、activity状态保存时-顺便保存fragment的状态-恢复状态同理" class="header-anchor">#</a> 5.2.1、Activity状态保存时，顺便保存Fragment的状态，恢复状态同理</h4> <p>这种情况属于自动发生的情况，上文讲<code>Activity</code>的状态保存时提到，<code>Activity</code>的实例状态其实也包含了<code>Fragment</code>的实例状态，因此<code>Activity</code>保存状态中也包含了<code>Fragment</code>的状态。</p> <p>通过图示来理解这个过程：</p> <center><img src="/assets/img/savedstate_12.9b166651.png" alt="savedstate_12" style="zoom:100%;"></center> <p>这种情况就是官方文档中提到的「宿主<code>Activity</code>」调用<code>Fragment</code>的<code>onSaveInstanceState()</code>的时候保存状态的情况。</p> <h4 id="_5-2-2、主动保存与恢复fragment的状态"><a href="#_5-2-2、主动保存与恢复fragment的状态" class="header-anchor">#</a> 5.2.2、主动保存与恢复Fragment的状态</h4> <p>有时候<code>Fragment</code>并不一定要跟随<code>Activity</code>进行状态保存，在<code>Activity</code>的生命周期期间，其内部的<code>Fragment</code>也会主动保存与恢复状态，这暗示着这些<code>Fragment</code>存在着需要销毁实例的情况。</p> <p>下面我们讲讲如何主动保存与恢复这些<code>Fragment</code>的状态：</p> <p>首先我们看FragmentManager(1.5.5版本)的源码，其中存在着一个<code>saveFragmentInstanceState(Fragment)</code>的方法，它是public的因此开发者可以使用这个方法「主动保存一个<code>Fragment</code>的状态」，随后就可以抛弃掉这个<code>Fragment</code>实例。</p> <center><img src="/assets/img/savedstate_16.17ede37c.png" alt="savedstate_16" style="zoom:100%;"></center> <p>还可以看到，保存的状态为<code>SavedState</code>，随后我们可以根据这个状态去为新创建的<code>Fragment</code>实例恢复刚才的状态。</p> <p>那么我们应该如何为新创建的<code>Fragment</code>实例恢复呢？<code>Fragment</code>专门为这种情况提供了一个方法：</p> <center><img src="/assets/img/savedstate_17.cfa1ee2f.png" alt="savedstate_17" style="zoom:100%;"></center> <p>可以看到这个方法单纯就是为了初始化一个<code>Fragment</code>的状态，唯一需要注意的是：</p> <blockquote><p><code>setInitialSavedState(SavedState)</code>只能在<code>Fragment</code>被<code>FragmentManager</code>纳入管理之前调用。</p></blockquote> <p>这一对API的意义是什么呢？目的只有一个就是节省内存，因为开发者经常会遇到这种场景：</p> <blockquote><p><code>Fragment</code>暂时不可见，希望回收它的实例但是保存状态，稍后新建一个类型相同的<code>Fragment</code>实例，然后用刚才保存的状态将「新建的实例」恢复成「旧的实例」的状态。</p></blockquote> <p>如果你熟悉<code>ViewPager2</code>，那么你一定了解它的一个<code>offscreenPageLimit</code>的机制，<code>FragmentStateAdapter</code>这个适配器会将那些离视窗范围太远的<code>Fragment</code>销毁掉，这个场景就是上述的提到的。那么它又是如何在重新回到被销毁的<code>Fragment</code>的位置的时候将其状态恢复的呢？</p> <p>答案就是上文提到的主动恢复状态的方法：<code>setInitialSavedState(SavedState)</code>。</p> <center><img src="/assets/img/savedstate_18.88e8e627.png" alt="savedstate_18" style="zoom:100%;"></center> <p>虽然旧的<code>Fragment</code>实例被销毁了，但是<code>ViewPager2</code>通过保存它的状态的方式，稍后使用了一个新的<code>Fragment</code>与之前保存的状态恢复到了当初的样子。</p> <p>虽然开发者很少会实现自己的「跨Fragment实例的状态保存恢复机制」，但是理解其本质有利于理解<code>ViewPager</code>等框架的基础原理。</p> <h4 id="_5-2-3、fragment进入回退栈的时候"><a href="#_5-2-3、fragment进入回退栈的时候" class="header-anchor">#</a> 5.2.3、Fragment进入回退栈的时候</h4> <p>下面引用一段来自<a href="https://www.geeksforgeeks.org/fragment-lifecycle-in-android/" target="_blank" rel="noopener noreferrer">Fragment Lifecycle in Android - GeeksforGeeks<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>的图阐述一下<code>Fragment</code>特殊的生命周期：</p> <p><img src="https://media.geeksforgeeks.org/wp-content/uploads/20230120013956/AndroidFragmentLifecycle.png" alt=""></p> <p>在图中可以看出，从<code>onCreate()</code>到<code>onDestroy()</code>的生命周期中，<code>Fragment</code>还可能进入一个从<code>onCreateView()</code>到<code>onDestroyView()</code>的循环，这个循环的次数可能是大于1次的。</p> <p>换句话说，在<code>Fragment</code>实例被创建到被销毁的期间，它的<code>View</code>也许会经历1次或以上的重新创建。</p> <p>那么什么情况下会发生「只销毁View而不销毁实例」的情况呢？答案如标题所述，就是<code>Fragment</code>进入回退栈的时候。</p> <center><img src="/assets/img/savedstate_19.175a2e99.png" alt="savedstate_19" style="zoom:100%;"></center> <p>当开发者使用<code>FragmentManager</code>执行<code>replace</code>操作并调用了<code>addToBackStack()</code>的时候，意味着「使用了一个新的<code>Fragment</code>替换掉了旧的<code>Fragment</code>」，但是这个操作是可逆的，因为操作添加进了回退栈，也就意味着，用户按返回键的时候，会返回到之前那个被替换的<code>Fragment</code>。</p> <p>这意味着，旧的<code>Fragment</code>只是暂时被压到了一个栈中，待会仍然可以通过退栈的方式重新回到用户的屏幕中，这个旧的<code>Fragment</code>会经历onPause()-&gt;onStop()-&gt;onDestroyView()的过程，但是仅此而已。它的实例没有被销毁，只是<code>View</code>被销毁了而已。</p> <p>但是开发者仍然不需要担心<code>View</code>被销毁后，<code>View</code>中的实例状态丢失了，因为<code>Fragment</code>考虑到了这种情况，在<code>FragmentManager</code>检测到这种场景的时候，会主动让<code>Fragment</code>保存其<code>contentView</code>的状态并存放在<code>FragmentManager</code>中。</p> <p>然而对于开发者来说，并不需要额外花心思在如何处理<code>Fragment</code>的<code>contentView</code>的状态如何被保存，因为这个本质是属于<code>View</code>层面的东西，了解这个机制的含义更多是解决一些开发中的隐性问题：</p> <blockquote><p>Fragment的实例和UI的生命周期实则是分离的，不能将两者等同，例如不能简单的使用Fragment的生命周期回调对UI进行一些操作而是使用其contentView的生命周期，否则将会发生越界访问（UI销毁了仍尝试访问）或者内存泄漏。</p> <p>Fragment的UI初始化应该写在onCreateView()中而不是onCreate()，这样能避免在生命周期期间发生UI销毁，导致UI没有被重新初始化等问题。</p></blockquote> <h2 id="_6、古法状态保存的问题"><a href="#_6、古法状态保存的问题" class="header-anchor">#</a> 6、古法状态保存的问题</h2> <p>上述分点讨论了<code>View</code>、<code>Activity</code>、<code>Fragment</code>的古法状态保存，不知道读者是否感觉到了他们有一些设计上的缺陷呢？笔者这里总结了几点：</p> <p>我们以<code>Activity</code>为例，回顾一下它的状态保存：</p> <center><img src="/assets/img/savedstate_14.b15bf8e1.png" alt="savedstate_14" style="zoom:67%;"></center> <h3 id="_6-1、不同类型的状态之间混合在一起"><a href="#_6-1、不同类型的状态之间混合在一起" class="header-anchor">#</a> 6.1、不同类型的状态之间混合在一起</h3> <p>如果我们将一个页面中不同业务的状态，都通过同一种方式（key-value)全部缓存在<code>onSaveInstanceState(Bundle)</code>提供的<code>bundle</code>中，那么维护起来将十分的复杂。</p> <h3 id="_6-2、上层主动保存状态而不是状态持有者本身"><a href="#_6-2、上层主动保存状态而不是状态持有者本身" class="header-anchor">#</a> 6.2、上层主动保存状态而不是状态持有者本身</h3> <p>另外还要注意的是：<code>Activity</code>本质上需要在自身的基础上，通过重写方法的方式来保存和恢复一些状态，然后提供这些状态给别的组件使用。</p> <p>这样的问题是：状态的使用者往往不是<code>Activity</code>而是<code>Activity</code>的一些附属的组件，例如一些成员变量、<code>View</code>（这里的情况下把<code>View</code>的状态上升到了<code>Activity</code>来维护，也是开发中常见的一种方式）等。</p> <p>如果全部的状态都通过<code>Activity</code>亲自来维护和恢复，如果后续需要保存的状态多起来的话，将会为<code>Activity</code>的开发提高了很大的负担。再者这也是违背单一权责的，单个方法中需要管理的不同业务的状态太多了。</p> <h3 id="_6-3、缺乏统一的管理层"><a href="#_6-3、缺乏统一的管理层" class="header-anchor">#</a> 6.3、缺乏统一的管理层</h3> <p>Activity、Dialog、Fragment等不同场景均依赖自身的方法，缺乏统一的代码。数据的维护可能需要团队的代码规范。</p> <h3 id="_6-4、总结"><a href="#_6-4、总结" class="header-anchor">#</a> 6.4、总结</h3> <p>古法状态保存由于历史的原因，设计的缺陷非常的大，开发者很难在复杂的业务中精准、高效地保存页面状态。</p> <h2 id="_7、走向savedstate库"><a href="#_7、走向savedstate库" class="header-anchor">#</a> 7、走向SavedState库</h2> <p>谷歌为了解决上述的状态保存的问题，提出了SavedState库。</p> <p>让我们看看「SavedState」库的整体脉络：</p> <center><img src="/assets/img/savedstate_20.824b422f.png" alt="savedstate_20" style="zoom:100%;"></center> <p>图中可以看出，状态是缓存在<code>SavedStateRegistry</code>中的，而该Registry又通过不同的<code>SavedStateProvider</code>来保存不同类型的状态，达到了分类管理的效果。</p> <p>单纯一幅图是没法完全理解这个库的，下面进行分点讲解：</p> <h3 id="_7-1、关键类解析"><a href="#_7-1、关键类解析" class="header-anchor">#</a> 7.1、关键类解析</h3> <h4 id="_7-1-1、savedstateregistryowner"><a href="#_7-1-1、savedstateregistryowner" class="header-anchor">#</a> 7.1.1、SavedStateRegistryOwner</h4> <center><img src="/assets/img/savedstate_21.7eff889d.png" alt="savedstate_21" style="zoom:67%;"></center> <p>可以看到，<code>SavedStateRegistryOwner</code>是一个非常简单的接口，它的目的是对外提供一个<code>SavedStateRegistry</code>，这是一个集中管理状态的管理器，下文会提到这里略过。</p> <p>还需要注意的是，该接口是<code>LifecycleOwner</code>的子类，因此它拥有感知生命周期的能力。不难理解，毕竟需要状态保存与恢复需要发生在组件恰当的生命周期中。</p> <h4 id="_7-1-2、savedstateprovider"><a href="#_7-1-2、savedstateprovider" class="header-anchor">#</a> 7.1.2、SavedStateProvider</h4> <center><img src="/assets/img/savedstate_22.efd96d43.png" alt="savedstate_22" style="zoom:67%;"></center> <p><code>SavedStateProvider</code>是一个接口，它的含义是「状态提供器」，实现该接口的类本质上就是定义了如何保存一类状态的方式。当需要保存状态时，<code>SavedStateRegistry</code>就会让它管理的所有Provider按定义保存所有状态。</p> <h4 id="_7-1-3、savedstateregistry"><a href="#_7-1-3、savedstateregistry" class="header-anchor">#</a> 7.1.3、SavedStateRegistry</h4> <p><code>SavedStateRegistry</code>是一个管理器，管理着一系列的<code>SavedStateProvider</code>，当其拥有者重建时，Registry也会重新创建一个新的实例。当Registry的拥有者（例如<code>Activity</code>）被创建的时候，Registry就会尝试恢复之前保存的状态。</p> <p>让我们总体概览一下<code>SavedStateRegistry</code>的代码， 不用为复杂的代码感到担心，下面会详解：</p> <center><img src="/assets/img/savedstate_23.d0186532.png" alt="savedstate_23" style="zoom:67%;"></center> <h5 id="_7-1-3-1、注册与反注册「状态提供者」"><a href="#_7-1-3-1、注册与反注册「状态提供者」" class="header-anchor">#</a> 7.1.3.1、注册与反注册「状态提供者」</h5> <p>上文中提到，<code>SavedStateRegistry</code>是一个管理一系列<code>SavedStateProvider</code>的容器，因此它提供了一对方法用于注册和解绑这些<code>StateProvider</code>，稍后这些Provider在保存与恢复状态中起到了关键作用。</p> <center><img src="/assets/img/savedstate_24.11d4c492.png" alt="savedstate_24" style="zoom:67%;"></center> <h5 id="_7-1-3-2、恢复与消费状态"><a href="#_7-1-3-2、恢复与消费状态" class="header-anchor">#</a> 7.1.3.2、恢复与消费状态</h5> <p><code>SavedStateRegistry</code>分别提供了<code>performRestore(Bundle?)</code>和<code>consumeRestoredStateForKey(String?)</code>来实现状态的恢复与消费。</p> <center><img src="/assets/img/savedstate_25.b2e57b86.png" alt="savedstate_25" style="zoom:67%;"></center> <p>从代码中可见，「恢复状态」只是从外部的Bundle中抓取一部分存放到Registry内部，并没有去执行取值的操作。如果需要从恢复后的状态中取值，则再次多次调用<code>consumeRestoredStateForKey(String?)</code>来取状态。</p> <p>那么为什么「恢复状态」之后还要「消费状态」呢？</p> <p>这里笔者的结论是：存在「恢复状态后，还不能立即消费状态」的场景。因此谷歌在设计该Api的时候，把状态的消费单独分离出来，适配更多场景。</p> <blockquote><p>需要注意的是：消费状态必须要在状态保存发生之后，可以使用<code>SavedStateRegistry.isRestored</code>来判断，否则会异常。</p></blockquote> <h5 id="_7-1-3-3、保存状态"><a href="#_7-1-3-3、保存状态" class="header-anchor">#</a> 7.1.3.3、保存状态</h5> <p>保存状态的代码也非常简洁，就是将<code>SavedStateRegistry</code>中的所有<code>SavedStateProvider</code>集中打包放到外部的bundle中。</p> <center><img src="/assets/img/savedstate_26.aa87ace7.png" alt="savedstate_26" style="zoom:67%;"></center> <h4 id="_7-1-4、savedstateregistrycontroller"><a href="#_7-1-4、savedstateregistrycontroller" class="header-anchor">#</a> 7.1.4、SavedStateRegistryController</h4> <p>这个类并没有什么特殊的，他只是<code>SavedStateRegistry</code>之间的包装类，结合<code>SavedStateRegistryOwner</code>做了一些生命周期上的工作，本质还是使用<code>performRestore(Bundle?)</code>和<code>performSave(Bundle?)</code>两个方法与<code>Registry</code>进行沟通：</p> <center><img src="/assets/img/savedstate_27.96314c1e.png" alt="savedstate_27" style="zoom:67%;"></center> <p>因为Controller多了与生命周期的监听，因此实际开发中，直接使用<code>SavedStateRegistry</code>还是比较少的，大多数使用<code>SavedStateRegistryController</code>来间接控制。</p> <h4 id="_7-1-5、总结"><a href="#_7-1-5、总结" class="header-anchor">#</a> 7.1.5、总结</h4> <p>让我们重新回到这张图中，根据刚才的解析总结一下各组件的功能：</p> <center><img src="/assets/img/savedstate_20.824b422f.png" alt="savedstate_20" style="zoom:100%;"></center> <ul><li>SavedStateRegistryOwner：<code>SavedStateRegistry</code>的提供者。</li> <li>StateRegistryController：间接控制<code>SavedStateRegistry</code>。</li> <li>SavedStateRegistry：状态的管理者。</li> <li>SavedStateProvider：状态的提供者。</li></ul> <h3 id="_7-3、谷歌眼中的savedstate"><a href="#_7-3、谷歌眼中的savedstate" class="header-anchor">#</a> 7.3、谷歌眼中的SavedState</h3> <p>我们结合谷歌提供的AndroidX代码来理解一下SavedState库是如何被使用的。</p> <h4 id="_7-3-1、componentdialog"><a href="#_7-3-1、componentdialog" class="header-anchor">#</a> 7.3.1、ComponentDialog</h4> <p>在<code>ComponentDialog</code>中，存在着SavedState库的核心代码，我们抽取出来看看：</p> <center><img src="/assets/img/savedstate_28.57d47e59.png" alt="savedstate_28" style="zoom:67%;"></center> <p>可见，该Dialog实现了<code>SavedStateRegistryOwner</code>接口，因此它可以对外提供<code>SavedStateRegistry</code>，上文中提到，由于<code>SavedStateController</code>包含的能力更多，因此都是直接使用<code>SavedStateController</code>来间接操控<code>SavedStateRegistry</code>。</p> <p>在<code>onSaveInstanceState()</code>中，使用了Controller来保存状态，而在<code>onCreate(Bundle?)</code>方法中，使用了Controller来恢复状态。</p> <p>还有一点值得注意的是，在<code>initViewTreeOwners()</code>方法中，将当前的<code>SavedStateRegistryOwner</code>绑定在了<code>Dialog</code>所在的<code>DecorView</code>中，这样给该<code>Dialog</code>下面的所有<code>View</code>提供了访问该<code>Dialog</code>的<code>SavedStateRegistry</code>的能力。</p> <blockquote><p>关于ViewTreeStateRegistryOwner的设计，在生命周期那一章已经简单阐述过类似的概念，不懂的读者可以回去阅读生命周期章。</p></blockquote> <h4 id="_7-3-2、componentactivity"><a href="#_7-3-2、componentactivity" class="header-anchor">#</a> 7.3.2、ComponentActivity</h4> <p>同时我们再看看<code>ComponentActivity</code>，本质上和Dialog也相似，关键代码已经全部截取出来了，读者结合Dialog的代码自行领会即可。</p> <p><code>Fragment</code>的几乎也一样，这里就不展示了。</p> <center><img src="/assets/img/savedstate_29.c32153f4.png" alt="savedstate_29" style="zoom:67%;"></center> <h2 id="_8、savedstate的最佳实践-savedstatehandle"><a href="#_8、savedstate的最佳实践-savedstatehandle" class="header-anchor">#</a> 8、SavedState的最佳实践——SavedStateHandle</h2> <blockquote><p>注意：本章涉及<code>ViewModel</code>相关知识点，如果你对ViewModel的实例化完全不理解可以去看<code>ViewModel</code>相关的章节</p></blockquote> <p>那么开发中如何使用SavedState呢，实际上开发者并不需要在项目中亲自试用SavedState，例如在Activity中直接使用<code>SavedStateRegistry</code>，而是配合<code>ViewModel</code>与其配套的<code>SavedStateHandle</code>一起使用。</p> <p>为什么会这样呢？因为直接在Activity、Fragment中声明变量已经不适合现代mvvm等开发模式了，而是将状态和逻辑写在<code>ViewModel</code>中，而<code>Activity</code>、<code>Fragment</code>等只做数据的订阅载体。</p> <p>因此ViewModel就需要一种访问其组件上的缓存的状态的能力，这里就引出本篇文章的主角——<code>SavedStateHandle</code>，我们直接先看看它是如何被使用的吧：</p> <center><img src="/assets/img/savedstate_30.6f385f3c.png" alt="savedstate_30" style="zoom:67%;"></center> <p>只需要在<code>ViewModel</code>的构造函数中添加<code>SavedStateHandle</code>这个参数即可，开发者通过<code>SavedStateHandle</code>可以读取到<code>Activity</code>的<code>getIntent()</code>的值，亦或者是读取到<code>Fragment</code>的<code>getArguments()</code>的值。相反的，也可以通过<code>SavedStateHandle</code>往里面写入值。</p> <p>这种用法有什么用呢？作用是两点：</p> <ol><li>读取<code>Activity</code>或者<code>Fragment</code>的入参。</li> <li>写入与读取状态，这些状态可以被状态保存机制保存起来。</li></ol> <p>第一点就不细说了，这个可以让<code>ViewModel</code>读取到当前所在组件的入参，做一些逻辑上的初始化工作。</p> <p>这里重点是第二点，如果你了解<code>ViewModel</code>，那么你肯定知道<code>ViewModel</code>在配置更新导致的组件重建的时候，是不会销毁的，然而一旦遇到非配置更新导致的重建的情况（例如处于Stoped状态的<code>Activity</code>由于内存不足被系统回收），<code>ViewModel</code>就会被销毁了。</p> <p>为了解决<code>ViewModel</code>在上述情况被销毁导致状态丢失的问题，开发者可以通过<code>SavedStateHandle</code>来写入和读取一些值，这个值会在发生状态保存的时候被写入到组件的Bundle中，并在组件组件重建的时候重新回到<code>SavedStateHandle</code>中，这让<code>ViewModel</code>拥有了读写状态的能力。</p> <h3 id="_8-1、savedstatehandle如何做到的"><a href="#_8-1、savedstatehandle如何做到的" class="header-anchor">#</a> 8.1、SavedStateHandle如何做到的</h3> <p>也许你一定很好奇<code>SavedStateHandle</code>是如何能够与<code>Activity</code>或者<code>Fragment</code>发生联系的，如果上述关于<code>ComponentActivity</code>等代码你还有印象，那么你肯定能猜到：</p> <blockquote><p><code>SavedStateHandle</code>访问了组件的<code>SavedStateRegistry</code>，并在上面读取和写了状态。</p></blockquote> <p>让我们通过代码来看看<code>SavedStateHandle</code>做了什么事：</p> <p>首先，<code>ViewModel</code>的构建都是通过工厂类反射得到的，因此我们使用了一个带参的<code>ViewModel</code>，那么必定存在一个对应的工厂类，这个工厂类在SavedState库中已经实现好了：</p> <center><img src="/assets/img/savedstate_31.a00de0b6.png" alt="savedstate_31" style="zoom:67%;"></center> <p>可以看到，这个工厂类在构建方法中允许传入一个外部的<code>SavedStateRegistryOwner</code>来获取其<code>SavedStateRegistry</code>，同时还传入了一个defaultArgs，还记得上面说的吗？这个参数在<code>Activity</code>中是<code>getIntent().getExtras()</code>，在<code>Fragment</code>中是<code>getArguments()</code>。我们直接在<code>ComponentActivity</code>的代码中验证下：</p> <center><img src="/assets/img/savedstate_32.480188b9.png" alt="savedstate_32" style="zoom:67%;"></center> <p>验证成功，关于<code>Fragment</code>读者可以亲自验证下，同样是<code>getDefaultViewModelProviderFactory()</code>方法。</p> <p>综上我们可以得出以下结论：</p> <ol><li><code>ViewModel</code>默认可以使用带<code>SaveStateHandle</code>的参数的构造函数，因为工厂方法已经默认提供了。</li> <li><code>SavedStateHandle</code>向<code>ViewModel</code>提供了读取组件入参、读取写入状态的能力。</li> <li><code>SavedStateHandle</code>的能力的基础源自工厂类拥有组件的<code>SaveStateRegistry</code>，因此<code>SavedStateHandle</code>被构建时同时也传入了组件的<code>SaveStateRegistry</code>。</li></ol> <p>下面用一张图简单描述一下它们的关系：</p> <center><img src="/assets/img/savedstate_33.059af658.png" alt="savedstate_33" style="zoom:100%;"></center> <h3 id="_8-2、状态保存的思路转变"><a href="#_8-2、状态保存的思路转变" class="header-anchor">#</a> 8.2、状态保存的思路转变</h3> <p>如果都通过<code>ViewModel</code>来保存业务中的状态，那么<code>View</code>又如何保存呢，毕竟<code>View</code>是没法直接访问<code>ViewModel</code>的，其实这陷入了一种思维的误区。</p> <p>进入MVVM时代之后，开发者更聚焦于状态本身，通过改变状态来让UI自动发生响应，因此<code>View</code>本身的状态可以「上升」到<code>ViewModel</code>中，组件发生销毁之后，ViewModel仍可以安全的保存状态，因此重新走一遍订阅状态的流程又可以让<code>View</code>恢复状态了。</p> <p>因此，并不是<code>View</code>不保存状态了，而是保存的位置迁移到了<code>ViewModel</code>。</p> <p>这里用一张新的图来阐述这种变化：</p> <center><img src="/assets/img/savedstate_34.b0cec8ba.png" alt="savedstate_34" style="zoom:76%;"></center> <h2 id="_9、引入savedstatehandle后-状态保存走向何方"><a href="#_9、引入savedstatehandle后-状态保存走向何方" class="header-anchor">#</a> 9、引入SavedStateHandle后，状态保存走向何方？</h2> <p>上文中提到，在引入MVVM开发思想以及对应的实现工具<code>ViewModel</code>之后，我们应该在<code>ViewModel</code>中结合<code>SavedStateHandle</code>来实现状态保存，但我们需要保存<code>ViewModel</code>中所有的属性吗？答案是不必要。</p> <p>首先，基于<code>ViewModel</code>的视角去看一看<code>SavedStateHandle</code>：</p> <center><img src="/assets/img/savedstate_35.1e97ec2c.png" alt="savedstate_35" style="zoom:67%;"></center> <p>可以看到ViewModel存在着两种类型的属性：</p> <ul><li>由SavedStateHandle直接管理的、ViewModel实例销毁时不会丢失的属性</li> <li>直接编码在ViewModel自身的临时变量</li></ul> <p>刚才提到，虽然开发者可以将一切变量都通过<code>SavedStateHandle</code>保存在状态中，避免<code>ViewModel</code>销毁后丢失，但是这是不必要的，为什么呢？下面从一个实际场景出发来解释下：</p> <p>假设页面A是一个列表，页面入参是用户的ID，从网络中加载用户相关的推荐房间数据。</p> <p>使用者进入到页面后，页面开始加载数据，同时使用者也在页面中勾选了一些筛选之类的选项。</p> <p>紧接着使用者收到了来电，APP进入了后台，页面也随即进入Stoped状态。</p> <p>不久之后，用户没有返回APP，而是使用了其他的APP，这导致了手机内存不足，原来的列表页面被<strong>系统回收</strong>。</p> <p>这个时候我们就要开始考虑哪些是需要保存的状态了：</p> <ul><li>对于入参ID，我们可以得知，所有入参是存在于Intent().getExtra()中的，在开发过程中不用担心这块数据因组件以外销毁而丢失。</li> <li>对于筛选选项之类的，笔者认为这一块是需要保存的，最好使用<code>SavedStateHandle</code>处理一下。</li> <li>对于加载的列表，笔者认为这一块是不需要保存的，如果长时间没有回来APP，即时性比较强的列表数据其实是没有恢复的必要，重新为用户加载一份并不是特别糟糕的体验。（注：个人观点，仍需要结合实际开发场景）</li></ul> <p>下面用代码来复现上述这种场景：</p> <center><img src="/assets/img/savedstate_36.f0c2e05c.png" alt="savedstate_36" style="zoom:67%;"></center> <p>代码很多，但是并不复杂，我们分别从<code>Activity</code>和<code>ViewModel</code>两部分讲解：</p> <p><strong>Activity</strong>：</p> <p>定义了一个uid的Key值以及一个伴生方法，用于其他页面跳转到当前<code>Activity</code>时在<code>Intent</code>的Extras中附带一个用户id的参数；</p> <p>添加了一个生命周期观察器，用于在进入Created时，调用<code>ViewModel</code>的方法去抓取数据。</p> <p><strong>ViewModel</strong>：</p> <p>使用<code>savedStateHandle</code>去读取<code>Activity</code>的Intent里面的Extra，用来获取用户id。</p> <p>定义了一个userFilter的Key值，用于通过<code>savedStateHandle</code>去读写<code>Activity</code>的Intent，用于避免开启筛选的状态在重建组件时丢失；</p> <p>定义了dataList用于缓存根据用户id请求的结果，但是此结果并不会保存在Intent中，因此会在组件因内存不足被系统销毁时丢失。</p> <p>最后笔者还是要说一句，决定哪些数据需要保存哪些数据可以放弃，这个要视乎实际项目的需要。</p> <h2 id="_10、总结"><a href="#_10、总结" class="header-anchor">#</a> 10、总结</h2> <p>本章中，我们从最古早的方法回调的方式了解如何保存与恢复状态，发现出许多旧版方式存在的缺陷，然后从SavedState库着手，以一种新的方式完成状态保存。可以看出近些年来谷歌在努力着手解决安卓整体框架的缺陷。</p></div></section> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev"><a href="/blogs/生命周期.html" class="prev">
          生命周期与Lifecycle
        </a></span> <span class="next"><a href="/blogs/ViewModel.html">
          传世不朽ViewModel
        </a></span></p></div> <div class="comments-wrapper"><!----></div></main></div> <!----></div> <ul class="sub-sidebar sub-sidebar-wrapper" style="width:12rem;" data-v-b57cc07c data-v-7dd95ae2><li class="level-2" data-v-b57cc07c><a href="/blogs/%E7%8A%B6%E6%80%81%E4%BF%9D%E5%AD%98.html#_1、为什么需要状态保存" class="sidebar-link reco-side-_1、为什么需要状态保存" data-v-b57cc07c>1、为什么需要状态保存？</a></li><li class="level-2" data-v-b57cc07c><a href="/blogs/%E7%8A%B6%E6%80%81%E4%BF%9D%E5%AD%98.html#_2、状态在安卓中意味着什么" class="sidebar-link reco-side-_2、状态在安卓中意味着什么" data-v-b57cc07c>2、状态在安卓中意味着什么</a></li><li class="level-2" data-v-b57cc07c><a href="/blogs/%E7%8A%B6%E6%80%81%E4%BF%9D%E5%AD%98.html#_3、图示状态保存与恢复" class="sidebar-link reco-side-_3、图示状态保存与恢复" data-v-b57cc07c>3、图示状态保存与恢复</a></li><li class="level-2" data-v-b57cc07c><a href="/blogs/%E7%8A%B6%E6%80%81%E4%BF%9D%E5%AD%98.html#_4、实操状态保存与恢复" class="sidebar-link reco-side-_4、实操状态保存与恢复" data-v-b57cc07c>4、实操状态保存与恢复</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/%E7%8A%B6%E6%80%81%E4%BF%9D%E5%AD%98.html#_4-1、view" class="sidebar-link reco-side-_4-1、view" data-v-b57cc07c>4.1、View</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/%E7%8A%B6%E6%80%81%E4%BF%9D%E5%AD%98.html#_4-2、activity" class="sidebar-link reco-side-_4-2、activity" data-v-b57cc07c>4.2、Activity</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/%E7%8A%B6%E6%80%81%E4%BF%9D%E5%AD%98.html#_4-3、fragment" class="sidebar-link reco-side-_4-3、fragment" data-v-b57cc07c>4.3、Fragment</a></li><li class="level-2" data-v-b57cc07c><a href="/blogs/%E7%8A%B6%E6%80%81%E4%BF%9D%E5%AD%98.html#_5、状态保存与恢复的时机" class="sidebar-link reco-side-_5、状态保存与恢复的时机" data-v-b57cc07c>5、状态保存与恢复的时机？</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/%E7%8A%B6%E6%80%81%E4%BF%9D%E5%AD%98.html#_5-1、activity" class="sidebar-link reco-side-_5-1、activity" data-v-b57cc07c>5.1、Activity</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/%E7%8A%B6%E6%80%81%E4%BF%9D%E5%AD%98.html#_5-2、fragment" class="sidebar-link reco-side-_5-2、fragment" data-v-b57cc07c>5.2、Fragment</a></li><li class="level-2" data-v-b57cc07c><a href="/blogs/%E7%8A%B6%E6%80%81%E4%BF%9D%E5%AD%98.html#_6、古法状态保存的问题" class="sidebar-link reco-side-_6、古法状态保存的问题" data-v-b57cc07c>6、古法状态保存的问题</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/%E7%8A%B6%E6%80%81%E4%BF%9D%E5%AD%98.html#_6-1、不同类型的状态之间混合在一起" class="sidebar-link reco-side-_6-1、不同类型的状态之间混合在一起" data-v-b57cc07c>6.1、不同类型的状态之间混合在一起</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/%E7%8A%B6%E6%80%81%E4%BF%9D%E5%AD%98.html#_6-2、上层主动保存状态而不是状态持有者本身" class="sidebar-link reco-side-_6-2、上层主动保存状态而不是状态持有者本身" data-v-b57cc07c>6.2、上层主动保存状态而不是状态持有者本身</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/%E7%8A%B6%E6%80%81%E4%BF%9D%E5%AD%98.html#_6-3、缺乏统一的管理层" class="sidebar-link reco-side-_6-3、缺乏统一的管理层" data-v-b57cc07c>6.3、缺乏统一的管理层</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/%E7%8A%B6%E6%80%81%E4%BF%9D%E5%AD%98.html#_6-4、总结" class="sidebar-link reco-side-_6-4、总结" data-v-b57cc07c>6.4、总结</a></li><li class="level-2" data-v-b57cc07c><a href="/blogs/%E7%8A%B6%E6%80%81%E4%BF%9D%E5%AD%98.html#_7、走向savedstate库" class="sidebar-link reco-side-_7、走向savedstate库" data-v-b57cc07c>7、走向SavedState库</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/%E7%8A%B6%E6%80%81%E4%BF%9D%E5%AD%98.html#_7-1、关键类解析" class="sidebar-link reco-side-_7-1、关键类解析" data-v-b57cc07c>7.1、关键类解析</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/%E7%8A%B6%E6%80%81%E4%BF%9D%E5%AD%98.html#_7-3、谷歌眼中的savedstate" class="sidebar-link reco-side-_7-3、谷歌眼中的savedstate" data-v-b57cc07c>7.3、谷歌眼中的SavedState</a></li><li class="level-2" data-v-b57cc07c><a href="/blogs/%E7%8A%B6%E6%80%81%E4%BF%9D%E5%AD%98.html#_8、savedstate的最佳实践-savedstatehandle" class="sidebar-link reco-side-_8、savedstate的最佳实践-savedstatehandle" data-v-b57cc07c>8、SavedState的最佳实践——SavedStateHandle</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/%E7%8A%B6%E6%80%81%E4%BF%9D%E5%AD%98.html#_8-1、savedstatehandle如何做到的" class="sidebar-link reco-side-_8-1、savedstatehandle如何做到的" data-v-b57cc07c>8.1、SavedStateHandle如何做到的</a></li><li class="level-3" data-v-b57cc07c><a href="/blogs/%E7%8A%B6%E6%80%81%E4%BF%9D%E5%AD%98.html#_8-2、状态保存的思路转变" class="sidebar-link reco-side-_8-2、状态保存的思路转变" data-v-b57cc07c>8.2、状态保存的思路转变</a></li><li class="level-2" data-v-b57cc07c><a href="/blogs/%E7%8A%B6%E6%80%81%E4%BF%9D%E5%AD%98.html#_9、引入savedstatehandle后-状态保存走向何方" class="sidebar-link reco-side-_9、引入savedstatehandle后-状态保存走向何方" data-v-b57cc07c>9、引入SavedStateHandle后，状态保存走向何方？</a></li><li class="level-2" data-v-b57cc07c><a href="/blogs/%E7%8A%B6%E6%80%81%E4%BF%9D%E5%AD%98.html#_10、总结" class="sidebar-link reco-side-_10、总结" data-v-b57cc07c>10、总结</a></li></ul></div></div></div><div class="global-ui"><div class="back-to-ceiling" style="right:1rem;bottom:6rem;width:2.5rem;height:2.5rem;border-radius:.25rem;line-height:2.5rem;display:none;" data-v-c6073ba8 data-v-c6073ba8><svg t="1574745035067" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="5404" class="icon" data-v-c6073ba8><path d="M526.60727968 10.90185116a27.675 27.675 0 0 0-29.21455937 0c-131.36607665 82.28402758-218.69155461 228.01873535-218.69155402 394.07834331a462.20625001 462.20625001 0 0 0 5.36959153 69.94390903c1.00431239 6.55289093-0.34802892 13.13561351-3.76865779 18.80351572-32.63518765 54.11355614-51.75690182 118.55860487-51.7569018 187.94566865a371.06718723 371.06718723 0 0 0 11.50484808 91.98906777c6.53300375 25.50556257 41.68394495 28.14064038 52.69160883 4.22606766 17.37162448-37.73630017 42.14135425-72.50938081 72.80769204-103.21549295 2.18761121 3.04276886 4.15646224 6.24463696 6.40373557 9.22774369a1871.4375 1871.4375 0 0 0 140.04691725 5.34970492 1866.36093723 1866.36093723 0 0 0 140.04691723-5.34970492c2.24727335-2.98310674 4.21612437-6.18497483 6.3937923-9.2178004 30.66633723 30.70611158 55.4360664 65.4791928 72.80769147 103.21549355 11.00766384 23.91457269 46.15860503 21.27949489 52.69160879-4.22606768a371.15156223 371.15156223 0 0 0 11.514792-91.99901164c0-69.36717486-19.13165746-133.82216804-51.75690182-187.92578088-3.42062944-5.66790279-4.76302748-12.26056868-3.76865837-18.80351632a462.20625001 462.20625001 0 0 0 5.36959269-69.943909c-0.00994388-166.08943902-87.32547796-311.81420293-218.6915546-394.09823051zM605.93803103 357.87693858a93.93749974 93.93749974 0 1 1-187.89594924 6.1e-7 93.93749974 93.93749974 0 0 1 187.89594924-6.1e-7z" p-id="5405" data-v-c6073ba8></path><path d="M429.50777625 765.63860547C429.50777625 803.39355007 466.44236686 1000.39046097 512.00932183 1000.39046097c45.56695499 0 82.4922232-197.00623328 82.5015456-234.7518555 0-37.75494459-36.9345906-68.35043303-82.4922232-68.34111062-45.57627738-0.00932239-82.52019037 30.59548842-82.51086798 68.34111062z" p-id="5406" data-v-c6073ba8></path></svg></div></div></div>
    <script src="/assets/js/app.a2aee210.js" defer></script><script src="/assets/js/7.83b45c61.js" defer></script><script src="/assets/js/2.4e1717d6.js" defer></script><script src="/assets/js/1.448f1724.js" defer></script><script src="/assets/js/15.b5939b09.js" defer></script>
  </body>
</html>
